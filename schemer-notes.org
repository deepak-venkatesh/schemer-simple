#+LATEX_HEADER: \setlength{\parindent}{0pt}

#+title: The Little Schemer Simplified
#+author: Deepak Venkatesh

#+LATEX: \newpage
*Note:*

#+LATEX: \vspace{1em}

These are my personal notes created to deepen my understanding of Lisp and programming in general. `The Little Schemer'
(4th edition) by Daniel Friedman and Matthias Felleisen is a remarkable book that teaches programming concepts in a
unique and playful way. It builds from first principles using only a small set of primitives, showing how powerful
ideas — such as recursion, functional programming, lambda functions, and interpreters — can be expressed using just
those few building blocks. I am making this public since other beginners could benefit from these notes.

While the book uses Scheme, I initially worked it out using Common Lisp and had adapted the examples accordingly. Now
I am working through it using Racket, a modern descendent of Scheme. Despite its lighthearted tone, the book is far
from an easy read — it demands close attention and careful thought. My advice to anyone who wants to learn lisp is to
first work through Professor David Touretzky's book titled `Common Lisp A Gentle Introduction to Symbolic Computing'
(2nd ed.). It's a great book for introduction to programming not just Lisp.

All mistakes in these notes, whether typographical or conceptual, are entirely my own. Any misinterpretations are as
well. I am still new to both Lisp and programming.

#+LATEX: \vspace{1em}

/Hardware and Software used for this study/
+ Language: Racket (a Scheme)
+ Editor: Dr Racket
+ emacs for org notes
+ Macbook Pro 2019 2.6 Ghz I7 Intel chip with 16 GB RAM

#+LATEX: \newpage
* Foreword

By Gerald Sussman of MIT, co-author of the book SICP (the wizard book).

#+LATEX: \vspace{1em}

Key Takeaway:
/In order to be creative one must first gain control of the medium./

#+LATEX: \vspace{1em}

+ Core skills are the first set of things required to master any pursuit.
+ Deep understanding is required to visualize beforehand the program which will be written.
+ Lisp provides freedom and flexibility (this is something which will only come in due course of time, as we keep
  learning more about programming).
+ Lisp was initially conceived as a theoretical vehicle for recursion and symbolic algebra (this is the algebra we
  have been taught in school such as $(a + b)^2 = a^2 + b^2 + 2ab$).
+ In Lisp procedures are first class. Procedures are essentially a `variant' of functions. A mathematical function
  maps a given input to an output (domain - range/co-domain) but a procedure is a process to arrive at the result via
  computation.
+ First Class basically means that the procedure itself can be passed around as arguments to other procedures.
  Procedures can be return values. They can also be stored in data structures. A similar corollary (though not exact)
  are composite functions which are usually taught in pre-calculus.
+ Lisp programs can manipulate representations of Lisp programs - this likely refers to macros and how in Lisp code
  can be treated as data.

#+LATEX: \vspace{1em}

*Core Terms/Concepts Learnt*
+ None

#+LATEX: \newpage
* Preface

Key Takeaway:
/The goal of the book is to teach the reader to think recursively./

#+LATEX: \vspace{1em}

+ Programs take data, apply a process on that data, and then produce some data.
+ Recursion is the act of defining an object or solving a problem in terms of itself.
+ The authors believe that writing programs recursively in Lisp is essentially pattern recongnition. Well I think
  it's true for any programming language or any programming paradigm.
+ For recursive programming and studying, this book we will need only a few primitives/functions, namely:
  + ~car~
  + ~cdr~
  + ~cons~
  + ~atom?~
  + ~eq?~
  + ~null?~
  + ~add1~, ~sub1~
  + ~and~, ~or~
  + ~else~
  + ~lambda~
  + ~cond~
  + ~define~
+ The definitions of the above primitives I am not outlining here and will come to it as we work through the book.
+ Authors advise to read this book slowly. Very slowly and delibrately. Re-read it multiple times. Every concept
  should be clear before going onto the next page.
+ In the preface we hit the first difference between Scheme and Common Lisp. ~()~ in Scheme is actually different
  from that in Common Lisp. Scheme considers ~()~ as /only/ a list and /not/ an atom. While in Common Lisp ~()~ is
  considered both an atom and a list. ~ATOM~ is defined as per the Lisp Hyperspec as well as Common Lisp The
  Language (2nd ed.) by Guy Steele as `The predicate ~ATOM~ is true if its argument is not a ~CONS~, and otherwise
  is false. In SBCL, a Common Lisp implementation  ~ATOM~ will give ~T~

  #+begin_src common-lisp
    (atom '())
    » T
    
  #+end_src

  We define our own predicate ~atom?~ in Scheme 

  #+begin_src scheme
    (define atom?
      (lambda (x)
	(and (not (pair? x)) (not (null? x)))))
    
  #+end_src

  Some tests for checking ~atom?~ in Scheme below

  #+begin_src scheme
    > (atom? 'a)
    #t
    > (atom? (quote ()))
    #f
    > (atom? '(a b c))
    #f
    > (atom? 42)
    #t
        
  #+end_src
  

*Core Terms/Concepts Learnt*
+ In Scheme ~()~ is only a list and not an atom.


#+LATEX: \newpage
* Toys

This chapter introduces primitives of Scheme. These are the basic building blocks.

#+LATEX: \vspace{1em}

** The Law of ~car~
Key Takeaway:
/The primitive ~car~ is defined only for non-empty lists. The ~car~ is the first atom (element) of that list./

#+LATEX: \vspace{1em}

+ An atom is indivisible - number, strings
+ Anything enclosed in parenthesis/brackets ~()~ is a list.
+ We can have nested lists which are also called improper lists and non-nested lists which are proper lists.
+ An S-expression which stands for Symbolic Expression is any Lisp object that can be read and evaluated by the
  Lisp reader.
+ Q. How many S-expressions are in the list ~(how are you doing so far)~ and what are they? The book answers 6 and
  those are the elements in the lists, basically the 6 atoms inside the list. 
+ A question asks how many S-expressions are in the list ~(((how) are) ((you) (doing so)) far)~ and gives the
  answer as 3. It refers to the 3 lists inside the outermost list.
+ The difference of ~()~ again comes up since it is both a list and an atom in Common Lisp unlike Scheme. The ~car~
  of ~()~ will be ~NIL~ in Common Lisp unlike Scheme. In Common Lisp as per the standards and empty list's ~car~ and
  ~cdr~ are both ~NIL~ (shown below).
  #+begin_src common-lisp
    (car ())
    » NIL
    
  #+end_src
+ ~car~ is the first atom/element of a list. If we try to find the ~car~ of a string of character or numbers we will
  get an error like below.
  #+begin_src scheme
      > (car 'a)
    . . car: contract violation
      expected: pair?
      given: 'a
    > (car 42)
    . . car: contract violation
      expected: pair?
      given: 42
    
  #+end_src

** The Law of ~cdr~
Key Takeaway:
/The primitive ~cdr~ is defined only for non-empty lists. The ~cdr~ of any non-empty list is always another list./

#+LATEX: \vspace{1em}

+ The book says ~car~ of /l/ is same as ~(car l)~. Similarly for ~cdr~.
+ ~cdr~ of a single atom/element list is ~()~.
+ In Tourtezky's book there is a tool called SDRAW. It allows us to do draw ~cons~ cell structures with the ~car~ &
  ~cdr~ pointers. I have uploaded the code for this tool on Github [[https://github.com/deepak-venkatesh/sdraw][here]]. For ~(car a)~ and ~(cdr a)~ where ~a~ is
  ~samosa~ will be represented as below (doesn't render well in markdown file on github):

  ~[*|*]---> NIL~ $\newline$
  ~|~ $\newline$
  ~|~ $\newline$
  ~V~ $\newline$
  ~SAMOSA~

+ ~cdr~ of an empty list will be ~()~ as per Common Lisp standards but in Scheme it is an error.


** The Law of ~cons~
Key Takeaway:
/The primitive ~cons~ takes two arguments. The second argument to ~cons~ must be a list. The result is a list./

#+LATEX: \vspace{1em}

+ ~cons~ actually creates a ~cons~ cell. The ~car~ of which is the first input to ~cons~ and the ~cdr~ is pointed to
  the second input. The return value of the ~cons~ is a pointer to it. Refer Touretzky's Chapter 2, clearly explained.
+ Q. What is ~(cons s l)~ where ~s~ is ~((a b c))~ and ~l~ is ~b~? This brings in the topic of Dotted Lists. In a
  proper list the chain of ~cons~ cells ends with ~()~ as the atom, meaning the last cell points to a ~NIL~ but in a
  dotted list the last atom points to a non ~NIL~ atom. In the above case we will get the following:
  #+begin_src scheme
    > (cons 'a '(b c))
    '(a b c)
    > (cons 'a 'b)
    '(a . b)
    
  #+end_src


** The Law of ~null?~
Key Takeaway:
/The primitive ~null?~ is defined only for lists./

#+LATEX: \vspace{1em}

+ Q. Is it true that the list ~l~ is the null list where ~l~ is ~()~? Yes, because it is  composed of
  zero S-expressions.
+ Another difference in Common Lisp and Scheme is how they refer to False. In scheme it is explicitly ~#t~ or ~#f~ but
  in Common Lisp it is ~T~ for True or else it is ~NIL~ which means False.
+ ~null?~ of an atom should throw an error for a string or a number but actually it gives ~#f~ since in Scheme ~null?~
  for ~()~ is ~#t~ and for everything else it is ~#f~. See code below.
  #+begin_src scheme
      > (null? 'a)
    #f
    > (null? (quote ()))
    #t
    
#+end_src

** The Law of ~eq?~
Key Takeaway:
/The primitive ~eq?~ in takes two arguments and compares them. Each must be a non numeric atom./

#+LATEX: \vspace{1em}

+ In ~eq?~ the address of the Lisp object is compared. For instance if we create two cons cells with same elements
  ~eq?~ will give ~#f~
  #+begin_src scheme
    > (eq? (cons 'a 'b) (cons 'a 'b))
    #f
    
#+end_src

*Core Terms/Concepts Learnt*
+ ~car~, ~cdr~, ~cons~, ~eq?~, ~null?~, ~quote~ / ~'~, ~#t~, ~#f~, 
+ Atoms, S-Expressions, Lists, Dotted Lists


#+LATEX: \newpage
* Do It, Do It Again, and Again, and Again ...

This chapter explains recursion. The best material for recursion in my opinion is Chapter 8 in Touretzky's book.

#+LATEX: \vspace{1em}

Key Takeaway:
/The First Commandment (preliminary): Always ask ~null?~ as the first question in expressing a function/

#+LATEX: \vspace{1em}
+ After reading Touretzky's chapter on recursion this chapter will feel very easy. Also the first commandment is not
  really true always. Sometimes in recursion the first question is not necessarily ~null?~. Later in the book the
  authors do add in this nuance.
+ The chapter introduces a function named ~lat?~. It stands for a list of atoms. This means every element of the
  list is an atom. It can be written as below.
  #+begin_src scheme
    (define lat?
      (lambda (l)
	(cond
	  ((null? l) #t)
	  ((atom? (car l)) (lat? (cdr l)))
	  (else #f))))

  #+end_src
+ It is important to understand how ~cond~ functions. Well ~cond~ is actually a macro. This macro has a series of
  tests and results. The macro goes from top to bottom. The cases are processed from left to right under each test.
  Technically we can have more than one result per test for evaluation. As a Lisp `trick' the last test is
  usually an ~else~ which evaluates to ~#t~ always and hence the last result is returned. ~cond~ is a very nice way to
  implement ~If..then..Else~. I have never seen such seamless conditional in any language yet.
+ ~lat?~ basically is a ~cond~ which keeps checking through all the elements of a list to test for ~atom?~ till the
  list ends. It checks ~car~ one by one for each subsequent ~cdr~ for ~atom?~.
+ I would study Chapter 8 of Touretzky for getting the intuition on recursion right. The author has done a great job.
+ Dr Racket comes with an inbuilt tool called ~trace~ in the library package called ~(racket/trace) which lets us see
  the actual function calls. So lets trace all the recursive examples in this chapter.
  #+begin_src scheme   
    > (lat? '(Jack Sprat could eat no chicken fat))
    >(lat? '(Jack Sprat could eat no chicken fat))
    >(lat? '(Sprat could eat no chicken fat))
    >(lat? '(could eat no chicken fat))
    >(lat? '(eat no chicken fat))
    >(lat? '(no chicken fat))
    >(lat? '(chicken fat))
    >(lat? '(fat))
    >(lat? '())
    <#t
    #t

  #+end_src
  
+ Another example which has a nested list
  #+begin_src scheme
    > (lat? '(Jack (Sprat could) eat no chicken fat))
    >(lat? '(Jack (Sprat could) eat no chicken fat))
    >(lat? '((Sprat could) eat no chicken fat))
    <#f
    #f
    
  #+end_src
+ Few more examples from the chapter using ~trace~
  #+begin_src scheme
    > (lat? '(bacon and eggs))
    >(lat? '(bacon and eggs))
    >(lat? '(and eggs))
    >(lat? '(eggs))
    >(lat? '())
    <#t
    #t

  #+end_src

  #+begin_src scheme
    > (lat? '(bacon (and eggs)))
    >(lat? '(bacon (and eggs)))
    >(lat? '((and eggs)))
    <#f
    #f

  #+end_src
+ ~or~ is introduced as a logical operator. ~or~ asks two questions, one at a time. If the first one is true it stops
  answers true. Otherwise it asks the second question and answers with whatever the second question answers.
+ ~member?~ is a function which returns a ~#t~ if the input is one of the elements in a list else ~#f~. The book
  defines this function using ~or~ whereas it is actually not necessary.
  #+begin_src scheme
	(define member?
	  (lambda (a lat)
	    (cond
	      ((null? lat) #f)
	      (else (or (eq? (car lat) a)
			 (member? a (cdr lat)))))))

    (define my-member?
      (lambda (a lat)
	(cond
	  ((null? lat) #f)
	  ((eq? (car lat) a) #t)
	  (else (member? a (cdr lat))))))
    
  #+end_src
+ The application of ~member?~ to find out whether /meat/ is in the list /(mashed potatoes and meat gravy)/ would
  generate this recursive call
  #+begin_src scheme
    > (member? 'meat '(mashed potatoes and meat gravy))
    >(member? 'meat '(mashed potatoes and meat gravy))
    >(member? 'meat '(potatoes and meat gravy))
    >(member? 'meat '(and meat gravy))
    >(member? 'meat '(meat gravy))
    <#t
    #t

  #+end_src
+ Another example
  #+begin_src scheme
    > (member? 'liver '(bagels and lox))
    >(member? 'liver '(bagels and lox))
    >(member? 'liver '(and lox))
    >(member? 'liver '(lox))
    >(member? 'liver '())
    <#f
    #f

  #+end_src

*Core Terms/Concepts Learnt*
+ ~or~
+ Basic template of recursion. Chapter 8 of Touretzky is great for a deeper dive into ways to construct recursion. Also
  tail optimized recursion is to be studied from the book `Sketchy Scheme' by Nils M Holm.

#+LATEX: \newpage

* Cons the Magnificent

This chapter explains the methods to build lists using ~cons~ recursively.

#+LATEX: \vspace{1em}

Key Takeaway:
/The Second Commandment: Use ~cons~ to build lists/
/The Third Commandment: When building a list, describe the first typical element, and then ~cons~ it onto the natural recursion/
/The Fourth Commandement: Always change at lest one argument while recurring. It must be changed to be closer to termination.
The changing argument must be tested in the termination condition: when using ~cdr~, test termination with ~null?~./

#+LATEX: \vspace{1em}

+ In last chapter we made a ~member?~ function and in this chapter we will be making a function which will /remove/
  a member
+ The first attempt to build the ~rember~ function fails since it removes all the initial elements before finding the
  one it wants to remove. The authors have nicely demonstrated why ~cons~ is required to define this function.
+ The way to write ~rember~ is as below. Also note as per Scheme semantics there is no ~?~ at the end
  of ~rember~ because it is actually not a predicate.
  #+begin_src scheme
    (define rember
      (lambda (a lat)
	(cond
	  ((null? lat) (quote ()))
	  ((eq? (car lat) a) (cdr lat))
	  (else (cons (car lat)
		      (rember a (cdr lat)))))))

  #+end_src
+ There is a way to contrast the incorrect ~rember~ with the correct ~cons~ ~rember~ by looking at the recursive
  trace calls. The incorrect ~rember-wrong~ is below with its trace and return.
  #+begin_src scheme
    (define rember-wrong
      (lambda (a lat)
	(cond
	  ((null? lat) #f)
	  ((eq? (car lat) a) #t)
	  (else (rember-wrong a (cdr lat))))))

    > (rember-wrong 'and '(bacon lettuce and tomato))
    >(rember-wrong 'and '(bacon lettuce and tomato))
    >(rember-wrong 'and '(lettuce and tomato))
    >(rember-wrong 'and '(and tomato))
    <'(tomato)
    '(tomato)

  #+end_src
  Whereas the correct trace and output is as below
  #+begin_src scheme
    > (rember 'and '(bacon lettuce and tomato))
    >(rember 'and '(bacon lettuce and tomato))
    > (rember 'and '(lettuce and tomato))
    > >(rember 'and '(and tomato))
    < <'(tomato)
    < '(lettuce tomato)
    <'(bacon lettuce tomato)
    '(bacon lettuce tomato)

  #+end_src
  Another example
  #+begin_src scheme
    > (rember 'sauce '(soy sauce and tomato sauce))
    >(rember 'sauce '(soy sauce and tomato sauce))
    > (rember 'sauce '(sauce and tomato sauce))
    < '(and tomato sauce)
    <'(soy and tomato sauce)
    '(soy and tomato sauce)

  #+end_src

+ Next function is ~firsts~ to build a list of the first S-expressions in nested lists. The code and trace is
  #+begin_src scheme
	(define firsts
	  (lambda (l)
	    (cond
	      ((null? l) (quote ()))
	      (else (cons (car (car l))
			  (firsts (cdr l)))))))

    >(firsts
      '((apple peach pumpkin)
	(plum pear cherry)
	(grape raisin pea)
	(bean carrot eggplant)))
    > (firsts '((plum pear cherry) (grape raisin pea) (bean carrot eggplant)))
    > >(firsts '((grape raisin pea) (bean carrot eggplant)))
    > > (firsts '((bean carrot eggplant)))
    > > >(firsts '())
    < < <'()
    < < '(bean)
    < <'(grape bean)
    < '(plum grape bean)
    <'(apple plum grape bean)
    '(apple plum grape bean)
    
  #+end_src
+ The book refers to ~seconds~ but doesn't provide code for it. But I will try it out anyways.
  #+begin_src scheme
	(define seconds
	  (lambda (l)
	    (cond ((null? l) (quote ()))
		  (else (cons (car (cdr (car l)))
			      (seconds (cdr l)))))))

    >(seconds '((a b) (c d) (e f)))
    > (seconds '((c d) (e f)))
    > >(seconds '((e f)))
    > > (seconds '())
    < < '()
    < <'(f)
    < '(d f)
    <'(b d f)
    '(b d f)
    
  #+end_src
+ In the recursion technique of ~cons~-ing cells the last ~cons~ cells' ~cdr~ pointer will point to a ~nil~ or an
  empty list ~()~. Therefore, the usual terminal or base condition is to check for ~null?~ then ~cons~ a ~()~.
+ Although the book alludes to the fact that the ~cons~-ing can be in any direction the trace in Dr Racket actually
  shows the  ~cons~-ing with a ~<~ or a ~>~. So a ~()~ gets ~cons~-ed with the last recurring item and goes back to the
  first item. In the above example ~()~ is ~cons~-ed to ~f~ to make a list ~(f)~. This ~(f)~ is then ~cons~-ed to ~d~
  to make the list ~(d f)~. This ~(d f)~ is then ~cons~-ed to ~b~ to finally get ~(b d f)~.
+ Without looking into the questions was able to build these ~cons~-es for ~insertR~, ~insertL~, and ~subst~.
  #+begin_src scheme
    (define insertR
      (lambda (new old lat)
	(cond ((null? lat) (quote ()))
	      ((eq? old (car lat)) (cons (car lat) (cons new (cdr lat))))
	      (else (cons (car lat) (insertR new old (cdr lat)))))))

    (define insertL
      (lambda (new old lat)
	(cond ((null? lat) (quote ()))
	      ((eq? old (car lat)) (cons new (cons (car lat) (cdr lat))))
	      (else (cons (car lat) (insertL new old (cdr lat)))))))

    (define subst
      (lambda (new old lat)
	(cond ((null? lat) (quote ()))
	      ((eq? old (car lat)) (cons new (cdr lat)))
	      (else (cons (car lat) (subst new old (cdr lat)))))))

  #+end_src
+ ~subst2~ is another function defined in the book, it substitutes either the first occurrence of one thing or another.
  #+begin_src scheme
    (define subst2
      (lambda (new o1 o2 lat)
	(cond ((null? lat) (quote ()))
	      ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
	      (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

  #+end_src
+ ~subst2~ involves an ~or~ but a better example could be used such as below. Since trace will give a better view.
  #+begin_src scheme
	(define subst2
	  (lambda (new o1 o2 lat)
	    (cond ((null? lat) (quote ()))
		  ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
		  (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

    > (subst2 'vanilla 'chocolate 'banana
	      '(caramel raspberry ice cream with
			chocolate topping with some bananas))
    >(subst2
      'vanilla
      'chocolate
      'banana
      '(caramel raspberry ice cream with chocolate topping with some bananas))
    > (subst2
       'vanilla
       'chocolate
       'banana
       '(raspberry ice cream with chocolate topping with some bananas))
    > >(subst2
	'vanilla
	'chocolate
	'banana
	'(ice cream with chocolate topping with some bananas))
    > > (subst2
	 'vanilla
	 'chocolate
	 'banana
	 '(cream with chocolate topping with some bananas))
    > > >(subst2
	  'vanilla
	  'chocolate
	  'banana
	  '(with chocolate topping with some bananas))
    > > > (subst2
	   'vanilla
	   'chocolate
	   'banana
	   '(chocolate topping with some bananas))
    < < < '(vanilla topping with some bananas)
    < < <'(with vanilla topping with some bananas)
    < < '(cream with vanilla topping with some bananas)
    < <'(ice cream with vanilla topping with some bananas)
    < '(raspberry ice cream with vanilla topping with some bananas)
    <'(caramel raspberry ice cream with vanilla topping with some bananas)
    '(caramel raspberry ice cream with vanilla topping with some bananas)

  #+end_src
+ ~multirember~ is below. I am unsure why two ~else~ is used by the author. Probably I will learn it down the line. But the
  ~trace~ captures the series of recursive steps beautifully. Note the ~>~ and ~<~ they capture the stack trace nicely.
  #+begin_src scheme
	(define multirember
	  (lambda (a lat)
	    (cond ((null? lat) (quote ()))
		  ((eq? (car lat) a) (multirember a (cdr lat)))
		  (else (cons (car lat) (multirember a (cdr lat)))))))

    > (multirember 'cup '(coffee cup tea cup and hick cup))
    >(multirember 'cup '(coffee cup tea cup and hick cup))
    > (multirember 'cup '(cup tea cup and hick cup))
    > (multirember 'cup '(tea cup and hick cup))
    > >(multirember 'cup '(cup and hick cup))
    > >(multirember 'cup '(and hick cup))
    > > (multirember 'cup '(hick cup))
    > > >(multirember 'cup '(cup))
    > > >(multirember 'cup '())
    < < <'()
    < < '(hick)
    < <'(and hick)
    < '(tea and hick)
    <'(coffee tea and hick)
    '(coffee tea and hick)
    
  #+end_src
+ Function definition for other `multi' variants below: ~multiinsertR~, ~multiinsertL~, and ~multisubst~.
  #+begin_src scheme
	(define multiinsertR
	  (lambda (new old lat)
	    (cond ((null? lat) (quote ()))
		  ((eq? old (car lat))
		   (cons (car lat)(cons new (multiinsertR new old (cdr lat)))))
		  (else (cons (car lat) (multiinsertR new old (cdr lat)))))))

    > (multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
    >(multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
    > (multiinsertR 'bag 'cup '(cup tea cup and hick cup))
    > >(multiinsertR 'bag 'cup '(tea cup and hick cup))
    > > (multiinsertR 'bag 'cup '(cup and hick cup))
    > > >(multiinsertR 'bag 'cup '(and hick cup))
    > > > (multiinsertR 'bag 'cup '(hick cup))
    > > > >(multiinsertR 'bag 'cup '(cup))
    > > > > (multiinsertR 'bag 'cup '())
    < < < < '()
    < < < <'(cup bag)
    < < < '(hick cup bag)
    < < <'(and hick cup bag)
    < < '(cup bag and hick cup bag)
    < <'(tea cup bag and hick cup bag)
    < '(cup bag tea cup bag and hick cup bag)
    <'(coffee cup bag tea cup bag and hick cup bag)
    '(coffee cup bag tea cup bag and hick cup bag)

  #+end_src

  #+begin_src scheme
	(define multiinsertL
	  (lambda (new old lat)
	    (cond ((null? lat) (quote ()))
		  ((eq? old (car lat))
		   (cons new (cons (car lat) (multiinsertL new old (cdr lat)))))
		  (else (cons (car lat) (multiinsertL new old (cdr lat)))))))

	> (multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
    >(multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
    > (multiinsertL 'bag 'cup '(cup tea cup and hick cup))
    > >(multiinsertL 'bag 'cup '(tea cup and hick cup))
    > > (multiinsertL 'bag 'cup '(cup and hick cup))
    > > >(multiinsertL 'bag 'cup '(and hick cup))
    > > > (multiinsertL 'bag 'cup '(hick cup))
    > > > >(multiinsertL 'bag 'cup '(cup))
    > > > > (multiinsertL 'bag 'cup '())
    < < < < '()
    < < < <'(bag cup)
    < < < '(hick bag cup)
    < < <'(and hick bag cup)
    < < '(bag cup and hick bag cup)
    < <'(tea bag cup and hick bag cup)
    < '(bag cup tea bag cup and hick bag cup)
    <'(coffee bag cup tea bag cup and hick bag cup)
    '(coffee bag cup tea bag cup and hick bag cup)

  #+end_src

  #+begin_src scheme
	(define multisubst
	  (lambda (new old lat)
	    (cond ((null? lat) (quote ()))
		  ((eq? (car lat) old) (cons new (multisubst new old (cdr lat))))
		  (else (cons (car lat) (multisubst new old (cdr lat)))))))

    > (multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
    >(multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
    > (multisubst 'bag 'cup '(cup tea cup and hick cup))
    > >(multisubst 'bag 'cup '(tea cup and hick cup))
    > > (multisubst 'bag 'cup '(cup and hick cup))
    > > >(multisubst 'bag 'cup '(and hick cup))
    > > > (multisubst 'bag 'cup '(hick cup))
    > > > >(multisubst 'bag 'cup '(cup))
    > > > > (multisubst 'bag 'cup '())
    < < < < '()
    < < < <'(bag)
    < < < '(hick bag)
    < < <'(and hick bag)
    < < '(bag and hick bag)
    < <'(tea bag and hick bag)
    < '(bag tea bag and hick bag)
    <'(coffee bag tea bag and hick bag)
    '(coffee bag tea bag and hick bag)
    
  #+end_src
  
*Core Terms/Concepts Learnt*
+ <<<>>>>>>

* TODO 
#+LATEX: \newpage

* Numbers Games

This chapter explains <>

#+LATEX: \vspace{1em}

Key Takeaway:


#+LATEX: \vspace{1em}

+ In








































#+LATEX: \newpage

* * Oh My Gawd *: It's Full of Stars

#+LATEX: \newpage

* Shadows

#+LATEX: \newpage

* Friends and Relations

#+LATEX: \newpage

* Lambda the Ultimate

#+LATEX: \newpage

* ... and Again, and Again, and Again, ...

#+LATEX: \newpage

* What Is the Value of All of This?

#+LATEX: \newpage

* Intermission

#+LATEX: \newpage

* The Ten Commandments

#+LATEX: \newpage

* The Five Rules

#+LATEX: \newpage
