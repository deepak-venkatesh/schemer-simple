% Created 2025-10-28 Tue 19:51
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setlength{\parindent}{0pt}
\author{Deepak Venkatesh}
\date{\today}
\title{The Little Schemer Simplified}
\hypersetup{
 pdfauthor={Deepak Venkatesh},
 pdftitle={The Little Schemer Simplified},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle
\maketitle

\begin{abstract}
These are my personal notes created to deepen my understanding of Lisp and programming in general.
\textit{The Little Schemer} (4th edition) by Daniel Friedman and Matthias Felleisen is a remarkable book
that teaches programming concepts in a unique and playful way. It builds from first principles using only
a small set of primitives, showing how powerful ideas — such as recursion, functional programming, lambda
functions, closures, higher order functions, and interpreters — can be expressed using just those few building
blocks. I am sharing this since other beginners could benefit from these notes.

\bigskip

While the book uses Scheme, I initially worked it out using Common Lisp and had adapted the examples accordingly. Now
I am working through it using Racket, a modern descendent of Scheme. Despite its lighthearted tone, the book is far
from an easy read — it demands close attention and careful thought. My advice to anyone who wants to learn Lisp is to
first work through Professor David Touretzky's book titled `Common Lisp A Gentle Introduction to Symbolic Computing'
(2nd ed.). It's a great book for introduction to programming not just Lisp.

\bigskip

All mistakes in these notes, whether typographical or conceptual, are entirely my own. Any misinterpretations are as
well. I am still new to both Lisp and programming.

\vspace{1em}

\emph{Hardware and Software used for this study}
\begin{itemize}
\item Language: Racket (a Scheme)
\item Editor: Dr Racket
\item emacs for org notes
\item Macbook Pro 2019 2.6 Ghz I7 Intel chip with 16 GB RAM
\end{itemize}
\end{abstract}

\clearpage
\setcounter{tocdepth}{1}
\tableofcontents
\clearpage

\section{Foreword}
\label{sec:org2af1fda}

By Gerald Sussman of MIT, co-author of the book SICP (the wizard book).

\bigskip

Key Takeaway:
\emph{In order to be creative one must first gain control of the medium.}

\vspace{1em}

\begin{itemize}
\item Core skills are the first set of things required to master any pursuit.
\item Deep understanding is required to visualize beforehand the program which will be written.
\item Lisp provides freedom and flexibility (this is something which will only come in due course of time, as we keep
learning more about programming).
\item Lisp was initially conceived as a theoretical vehicle for recursion and symbolic algebra (this is the algebra we
have been taught in school such as \((a + b)^2 = a^2 + b^2 + 2ab\)).
\item In Lisp procedures are first class. Procedures are essentially a `variant' of functions. A mathematical function
maps a given input to an output (domain - range/co-domain) but a procedure is a process to arrive at the result via
computation.
\item First Class basically means that the procedure itself can be passed around as arguments to other procedures.
Procedures can be return values. They can also be stored in data structures. A similar corollary (though not exact)
are composite functions which are usually taught in pre-calculus.
\item Lisp programs can manipulate representations of Lisp programs - this likely refers to macros and how in Lisp code
can be treated as data.
\end{itemize}

\bigskip

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item None
\end{itemize}

\clearpage
\section{Preface}
\label{sec:org9e9782e}

Key Takeaway:
\emph{The goal of the book is to teach the reader to think recursively.}

\bigskip

\begin{itemize}
\item Programs take data, apply a process on that data, and then produce some data.
\item Recursion is the act of defining an object or solving a problem in terms of itself.
\item The authors believe that writing programs recursively in Lisp is essentially pattern recongnition. Well I think
it's true for any programming language or any programming paradigm.
\item For recursive programming and studying, this book we will need only a few primitives/functions, namely:
\begin{itemize}
\item \texttt{car}
\item \texttt{cdr}
\item \texttt{cons}
\item \texttt{atom?}
\item \texttt{eq?}
\item \texttt{null?}
\item \texttt{add1}, \texttt{sub1}
\item \texttt{and}, \texttt{or}
\item \texttt{else}
\item \texttt{lambda}
\item \texttt{cond}
\item \texttt{define}
\end{itemize}
\item The definitions of the above primitives I am not outlining here and will come to it as we work through the book.
\item Authors advise to read this book slowly. Very slowly and delibrately. Re-read it multiple times. Every concept
should be clear before going onto the next page.
\item In the preface we hit the first difference between Scheme and Common Lisp. \texttt{()} in Scheme is actually different
from that in Common Lisp. Scheme considers \texttt{()} as \emph{only} a list and \emph{not} an atom. While in Common Lisp \texttt{()} is
considered both an atom and a list. \texttt{ATOM} is defined as per the Lisp Hyperspec as well as Common Lisp The
Language (2nd ed.) by Guy Steele as `The predicate \texttt{ATOM} is true if its argument is not a \texttt{CONS}, and otherwise
is false. In SBCL, a Common Lisp implementation  \texttt{ATOM} will give \texttt{T}

\begin{verbatim}
(atom '())
» T

\end{verbatim}

We define our own predicate \texttt{atom?} in Scheme 

\begin{verbatim}
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

\end{verbatim}

Some tests for checking \texttt{atom?} in Scheme below

\begin{verbatim}
> (atom? 'a)
#t
> (atom? (quote ()))
#f
> (atom? '(a b c))
#f
> (atom? 42)
#t

\end{verbatim}
\end{itemize}


\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item In Scheme \texttt{()} is only a list and not an atom.
\end{itemize}


\newpage
\section{Toys}
\label{sec:org7ab4ca8}

This chapter introduces primitives of Scheme. These are the basic building blocks.

\bigskip

\subsection{The Law of \texttt{car}}
\label{sec:org7ab3290}
Key Takeaway:
\emph{The primitive \texttt{car} is defined only for non-empty lists. The \texttt{car} is the first atom (element) of that list.}

\vspace{1em}

\begin{itemize}
\item An atom is indivisible - number, strings
\item Anything enclosed in parenthesis/brackets \texttt{()} is a list.
\item We can have nested lists which are also called improper lists and non-nested lists which are proper lists.
\item An S-expression which stands for Symbolic Expression is any Lisp object that can be read and evaluated by the
Lisp reader.
\item Q. How many S-expressions are in the list \texttt{(how are you doing so far)} and what are they? The book answers 6 and
those are the elements in the lists, basically the 6 atoms inside the list.
\item A question asks how many S-expressions are in the list \texttt{(((how) are) ((you) (doing so)) far)} and gives the
answer as 3. It refers to the 3 lists inside the outermost list.
\item The difference of \texttt{()} again comes up since it is both a list and an atom in Common Lisp unlike Scheme. The \texttt{car}
of \texttt{()} will be \texttt{NIL} in Common Lisp unlike Scheme. In Common Lisp as per the standards and empty list's \texttt{car} and
\texttt{cdr} are both \texttt{NIL} (shown below).
\begin{verbatim}
(car ())
» NIL

\end{verbatim}
\item \texttt{car} is the first atom/element of a list. If we try to find the \texttt{car} of a string of character or numbers we will
get an error like below.
\begin{verbatim}
  > (car 'a)
. . car: contract violation
  expected: pair?
  given: 'a
> (car 42)
. . car: contract violation
  expected: pair?
  given: 42

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{cdr}}
\label{sec:org511a27d}
Key Takeaway:
\emph{The primitive \texttt{cdr} is defined only for non-empty lists. The \texttt{cdr} of any non-empty list is always another list.}

\vspace{1em}

\begin{itemize}
\item The book says \texttt{car} of \emph{l} is same as \texttt{(car l)}. Similarly for \texttt{cdr}.
\item \texttt{cdr} of a single atom/element list is \texttt{()}.
\item In Tourtezky's book there is a tool called SDRAW. It allows us to do draw \texttt{cons} cell structures with the \texttt{car} \&
\texttt{cdr} pointers. I have uploaded the code for this tool on Github \href{https://github.com/deepak-venkatesh/sdraw}{here}. For \texttt{(car a)} and \texttt{(cdr a)} where \texttt{a} is
\texttt{samosa} will be represented as below (doesn't render well in markdown file on github):

\texttt{[*|*]-{}-{}-> NIL} \(\newline\)
\texttt{|} \(\newline\)
\texttt{|} \(\newline\)
\texttt{V} \(\newline\)
\texttt{SAMOSA}

\item \texttt{cdr} of an empty list will be \texttt{()} as per Common Lisp standards but in Scheme it is an error.
\end{itemize}


\subsection{The Law of \texttt{cons}}
\label{sec:orgdab33e1}
Key Takeaway:
\emph{The primitive \texttt{cons} takes two arguments. The second argument to \texttt{cons} must be a list. The result is a list.}

\vspace{1em}

\begin{itemize}
\item \texttt{cons} actually creates a \texttt{cons} cell. The \texttt{car} of which is the first input to \texttt{cons} and the \texttt{cdr} is pointed to
the second input. The return value of the \texttt{cons} is a pointer to it. Refer Touretzky's Chapter 2, clearly explained.
\item Q. What is \texttt{(cons s l)} where \texttt{s} is \texttt{((a b c))} and \texttt{l} is \texttt{b}? This brings in the topic of Dotted Lists. In a
proper list the chain of \texttt{cons} cells ends with \texttt{()} as the atom, meaning the last cell points to a \texttt{NIL} but in a
dotted list the last atom points to a non \texttt{NIL} atom. In the above case we will get the following:
\begin{verbatim}
> (cons 'a '(b c))
'(a b c)
> (cons 'a 'b)
'(a . b)

\end{verbatim}
\end{itemize}


\subsection{The Law of \texttt{null?}}
\label{sec:org9c32ff2}
Key Takeaway:
\emph{The primitive \texttt{null?} is defined only for lists.}

\vspace{1em}

\begin{itemize}
\item Q. Is it true that the list \texttt{l} is the null list where \texttt{l} is \texttt{()}? Yes, because it is  composed of
zero S-expressions.
\item Another difference in Common Lisp and Scheme is how they refer to False. In scheme it is explicitly \texttt{\#t} or \texttt{\#f} but
in Common Lisp it is \texttt{T} for True or else it is \texttt{NIL} which means False.
\item \texttt{null?} of an atom should throw an error for a string or a number but actually it gives \texttt{\#f} since in Scheme \texttt{null?}
for \texttt{()} is \texttt{\#t} and for everything else it is \texttt{\#f}. See code below.
\begin{verbatim}
  > (null? 'a)
#f
> (null? (quote ()))
#t

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{eq?}}
\label{sec:org8ec9348}
Key Takeaway:
\emph{The primitive \texttt{eq?} in takes two arguments and compares them. Each must be a non numeric atom.}

\vspace{1em}

\begin{itemize}
\item In \texttt{eq?} the address of the Lisp object is compared. For instance if we create two cons cells with same elements
\texttt{eq?} will give \texttt{\#f}
\begin{verbatim}
> (eq? (cons 'a 'b) (cons 'a 'b))
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{car}, \texttt{cdr}, \texttt{cons}, \texttt{eq?}, \texttt{null?}, \texttt{quote} / \texttt{'}, \texttt{\#t}, \texttt{\#f}
\item Atoms, S-Expressions, Lists, Dotted Lists
\end{itemize}


\newpage
\section{Do It, Do It Again, and Again, and Again \ldots{}}
\label{sec:org1223484}

This chapter explains recursion. The best material for recursion in my opinion is Chapter 8 in Touretzky's book.

\vspace{1em}

Key Takeaway:
\emph{The First Commandment (preliminary): Always ask \texttt{null?} as the first question in expressing a function}

\vspace{1em}
\begin{itemize}
\item After reading Touretzky's chapter on recursion this chapter will feel very easy. Also the first commandment is not
really true always. Sometimes in recursion the first question is not necessarily \texttt{null?}. Later in the book the
authors do add in this nuance.
\item The chapter introduces a function named \texttt{lat?}. It stands for a list of atoms. This means every element of the
list is an atom. It can be written as below.
\begin{verbatim}
(define lat?
  (lambda (l)
    (cond
      ((null? l) #t)
      ((atom? (car l)) (lat? (cdr l)))
      (else #f))))

\end{verbatim}
\item It is important to understand how \texttt{cond} functions. Well \texttt{cond} is actually a macro. This macro has a series of
tests and results. The macro goes from top to bottom. The cases are processed from left to right under each test.
Technically we can have more than one result per test for evaluation. As a Lisp `trick' the last test is
usually an \texttt{else} which evaluates to \texttt{\#t} always and hence the last result is returned. \texttt{cond} is a very nice way to
implement \texttt{If..then..Else}. I have never seen such seamless conditional in any language yet.
\item \texttt{lat?} basically is a \texttt{cond} which keeps checking through all the elements of a list to test for \texttt{atom?} till the
list ends. It checks \texttt{car} one by one for each subsequent \texttt{cdr} for \texttt{atom?}.
\item I would study Chapter 8 of Touretzky for getting the intuition on recursion right. The author has done a great job.
\item Dr Racket comes with an inbuilt tool called \texttt{trace} in the library package called \textasciitilde{}(racket/trace) which lets us see
the actual function calls. So lets trace all the recursive examples in this chapter.
\begin{verbatim}
> (lat? '(Jack Sprat could eat no chicken fat))
>(lat? '(Jack Sprat could eat no chicken fat))
>(lat? '(Sprat could eat no chicken fat))
>(lat? '(could eat no chicken fat))
>(lat? '(eat no chicken fat))
>(lat? '(no chicken fat))
>(lat? '(chicken fat))
>(lat? '(fat))
>(lat? '())
<#t
#t

\end{verbatim}

\item Another example which has a nested list
\begin{verbatim}
> (lat? '(Jack (Sprat could) eat no chicken fat))
>(lat? '(Jack (Sprat could) eat no chicken fat))
>(lat? '((Sprat could) eat no chicken fat))
<#f
#f

\end{verbatim}
\item Few more examples from the chapter using \texttt{trace}
\begin{verbatim}
> (lat? '(bacon and eggs))
>(lat? '(bacon and eggs))
>(lat? '(and eggs))
>(lat? '(eggs))
>(lat? '())
<#t
#t

\end{verbatim}

\begin{verbatim}
> (lat? '(bacon (and eggs)))
>(lat? '(bacon (and eggs)))
>(lat? '((and eggs)))
<#f
#f

\end{verbatim}
\item \texttt{or} is introduced as a logical operator. \texttt{or} asks two questions, one at a time. If the first one is true it stops
answers true. Otherwise it asks the second question and answers with whatever the second question answers.
\item \texttt{member?} is a function which returns a \texttt{\#t} if the input is one of the elements in a list else \texttt{\#f}. The book
defines this function using \texttt{or} whereas it is actually not necessary.
\begin{verbatim}
    (define member?
      (lambda (a lat)
        (cond
          ((null? lat) #f)
          (else (or (eq? (car lat) a)
                     (member? a (cdr lat)))))))

(define my-member?
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      ((eq? (car lat) a) #t)
      (else (member? a (cdr lat))))))

\end{verbatim}
\item The application of \texttt{member?} to find out whether \emph{meat} is in the list \emph{(mashed potatoes and meat gravy)} would
generate this recursive call
\begin{verbatim}
> (member? 'meat '(mashed potatoes and meat gravy))
>(member? 'meat '(mashed potatoes and meat gravy))
>(member? 'meat '(potatoes and meat gravy))
>(member? 'meat '(and meat gravy))
>(member? 'meat '(meat gravy))
<#t
#t

\end{verbatim}
\item Another example
\begin{verbatim}
> (member? 'liver '(bagels and lox))
>(member? 'liver '(bagels and lox))
>(member? 'liver '(and lox))
>(member? 'liver '(lox))
>(member? 'liver '())
<#f
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{or}
\item Basic template of recursion. Chapter 8 of Touretzky is great for a deeper dive into ways to construct recursion. Also
tail optimized recursion is to be studied from the book `Sketchy Scheme' by Nils M Holm.
\end{itemize}

\newpage

\section{Cons the Magnificent}
\label{sec:orgc031e1f}

This chapter explains the methods to build lists using \texttt{cons} recursively.

\vspace{1em}

Key Takeaway:
\emph{The Second Commandment: Use \texttt{cons} to build lists}
\vspace{0.5em}
\emph{The Third Commandment: When building a list, describe the first typical element, and then \texttt{cons} it onto the natural recursion}
\vspace{0.5em}
\emph{The Fourth Commandement: Always change at lest one argument while recurring. It must be changed to be closer to termination.
The changing argument must be tested in the termination condition: when using \texttt{cdr}, test termination with \texttt{null?}.}

\vspace{1em}

\begin{itemize}
\item In last chapter we made a \texttt{member?} function and in this chapter we will be making a function which will \emph{remove}
a member
\item The first attempt to build the \texttt{rember} function fails since it removes all the initial elements before finding the
one it wants to remove. The authors have nicely demonstrated why \texttt{cons} is required to define this function.
\item The way to write \texttt{rember} is as below. Also note as per Scheme semantics there is no \texttt{?} at the end
of \texttt{rember} because it is actually not a predicate.
\begin{verbatim}
(define rember
  (lambda (a lat)
    (cond
      ((null? lat) (quote ()))
      ((eq? (car lat) a) (cdr lat))
      (else (cons (car lat)
                  (rember a (cdr lat)))))))

\end{verbatim}
\item There is a way to contrast the incorrect \texttt{rember} with the correct \texttt{cons} \texttt{rember} by looking at the recursive
trace calls. The incorrect \texttt{rember-wrong} is below with its trace and return.
\begin{verbatim}
(define rember-wrong
  (lambda (a lat)
    (cond
      ((null? lat) #f)
      ((eq? (car lat) a) #t)
      (else (rember-wrong a (cdr lat))))))

> (rember-wrong 'and '(bacon lettuce and tomato))
>(rember-wrong 'and '(bacon lettuce and tomato))
>(rember-wrong 'and '(lettuce and tomato))
>(rember-wrong 'and '(and tomato))
<'(tomato)
'(tomato)

\end{verbatim}
Whereas the correct trace and output is as below
\begin{verbatim}
> (rember 'and '(bacon lettuce and tomato))
>(rember 'and '(bacon lettuce and tomato))
> (rember 'and '(lettuce and tomato))
> >(rember 'and '(and tomato))
< <'(tomato)
< '(lettuce tomato)
<'(bacon lettuce tomato)
'(bacon lettuce tomato)

\end{verbatim}
Another example
\begin{verbatim}
> (rember 'sauce '(soy sauce and tomato sauce))
>(rember 'sauce '(soy sauce and tomato sauce))
> (rember 'sauce '(sauce and tomato sauce))
< '(and tomato sauce)
<'(soy and tomato sauce)
'(soy and tomato sauce)

\end{verbatim}

\item Next function is \texttt{firsts} to build a list of the first S-expressions in nested lists. The code and trace is
\begin{verbatim}
    (define firsts
      (lambda (l)
        (cond
          ((null? l) (quote ()))
          (else (cons (car (car l))
                      (firsts (cdr l)))))))

>(firsts
  '((apple peach pumpkin)
    (plum pear cherry)
    (grape raisin pea)
    (bean carrot eggplant)))
> (firsts '((plum pear cherry) (grape raisin pea) (bean carrot eggplant)))
> >(firsts '((grape raisin pea) (bean carrot eggplant)))
> > (firsts '((bean carrot eggplant)))
> > >(firsts '())
< < <'()
< < '(bean)
< <'(grape bean)
< '(plum grape bean)
<'(apple plum grape bean)
'(apple plum grape bean)

\end{verbatim}
\item The book refers to \texttt{seconds} but doesn't provide code for it. But I will try it out anyways.
\begin{verbatim}
    (define seconds
      (lambda (l)
        (cond ((null? l) (quote ()))
              (else (cons (car (cdr (car l)))
                          (seconds (cdr l)))))))

>(seconds '((a b) (c d) (e f)))
> (seconds '((c d) (e f)))
> >(seconds '((e f)))
> > (seconds '())
< < '()
< <'(f)
< '(d f)
<'(b d f)
'(b d f)

\end{verbatim}
\item In the recursion technique of \texttt{cons}-ing cells the last \texttt{cons} cells' \texttt{cdr} pointer will point to a \texttt{nil} or an
empty list \texttt{()}. Therefore, the usual terminal or base condition is to check for \texttt{null?} then \texttt{cons} a \texttt{()}.
\item Although the book alludes to the fact that the \texttt{cons}-ing can be in any direction the trace in Dr Racket actually
shows the  \texttt{cons}-ing with a \texttt{<} or a \texttt{>}. So a \texttt{()} gets \texttt{cons}-ed with the last recurring item and goes back to the
first item. In the above example \texttt{()} is \texttt{cons}-ed to \texttt{f} to make a list \texttt{(f)}. This \texttt{(f)} is then \texttt{cons}-ed to \texttt{d}
to make the list \texttt{(d f)}. This \texttt{(d f)} is then \texttt{cons}-ed to \texttt{b} to finally get \texttt{(b d f)}.
\item Without looking into the questions was able to build these \texttt{cons}-es for \texttt{insertR}, \texttt{insertL}, and \texttt{subst}.
\begin{verbatim}
(define insertR
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons (car lat) (cons new (cdr lat))))
          (else (cons (car lat) (insertR new old (cdr lat)))))))

(define insertL
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons new (cons (car lat) (cdr lat))))
          (else (cons (car lat) (insertL new old (cdr lat)))))))

(define subst
  (lambda (new old lat)
    (cond ((null? lat) (quote ()))
          ((eq? old (car lat)) (cons new (cdr lat)))
          (else (cons (car lat) (subst new old (cdr lat)))))))

\end{verbatim}
\item \texttt{subst2} is another function defined in the book, it substitutes either the first occurrence of one thing or another.
\begin{verbatim}
(define subst2
  (lambda (new o1 o2 lat)
    (cond ((null? lat) (quote ()))
          ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
          (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

\end{verbatim}
\item \texttt{subst2} involves an \texttt{or} but a better example could be used such as below. Since trace will give a better view.
\begin{verbatim}
    (define subst2
      (lambda (new o1 o2 lat)
        (cond ((null? lat) (quote ()))
              ((or (eq? (car lat) o1) (eq? (car lat) o2)) (cons new (cdr lat)))
              (else (cons (car lat) (subst2 new o1 o2 (cdr lat)))))))

> (subst2 'vanilla 'chocolate 'banana
          '(caramel raspberry ice cream with
                    chocolate topping with some bananas))
>(subst2
  'vanilla
  'chocolate
  'banana
  '(caramel raspberry ice cream with chocolate topping with some bananas))
> (subst2
   'vanilla
   'chocolate
   'banana
   '(raspberry ice cream with chocolate topping with some bananas))
> >(subst2
    'vanilla
    'chocolate
    'banana
    '(ice cream with chocolate topping with some bananas))
> > (subst2
     'vanilla
     'chocolate
     'banana
     '(cream with chocolate topping with some bananas))
> > >(subst2
      'vanilla
      'chocolate
      'banana
      '(with chocolate topping with some bananas))
> > > (subst2
       'vanilla
       'chocolate
       'banana
       '(chocolate topping with some bananas))
< < < '(vanilla topping with some bananas)
< < <'(with vanilla topping with some bananas)
< < '(cream with vanilla topping with some bananas)
< <'(ice cream with vanilla topping with some bananas)
< '(raspberry ice cream with vanilla topping with some bananas)
<'(caramel raspberry ice cream with vanilla topping with some bananas)
'(caramel raspberry ice cream with vanilla topping with some bananas)

\end{verbatim}
\item \texttt{multirember} is below. I am unsure why two \texttt{else} is used by the author. Probably I will learn it down the line. But the
\texttt{trace} captures the series of recursive steps beautifully. Note the \texttt{>} and \texttt{<} they capture the stack trace nicely.
\begin{verbatim}
    (define multirember
      (lambda (a lat)
        (cond ((null? lat) (quote ()))
              ((eq? (car lat) a) (multirember a (cdr lat)))
              (else (cons (car lat) (multirember a (cdr lat)))))))

> (multirember 'cup '(coffee cup tea cup and hick cup))
>(multirember 'cup '(coffee cup tea cup and hick cup))
> (multirember 'cup '(cup tea cup and hick cup))
> (multirember 'cup '(tea cup and hick cup))
> >(multirember 'cup '(cup and hick cup))
> >(multirember 'cup '(and hick cup))
> > (multirember 'cup '(hick cup))
> > >(multirember 'cup '(cup))
> > >(multirember 'cup '())
< < <'()
< < '(hick)
< <'(and hick)
< '(tea and hick)
<'(coffee tea and hick)
'(coffee tea and hick)

\end{verbatim}
\item Function definition for other `multi' variants below: \texttt{multiinsertR}, \texttt{multiinsertL}, and \texttt{multisubst}.
\begin{verbatim}
    (define multiinsertR
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? old (car lat))
               (cons (car lat)(cons new (multiinsertR new old (cdr lat)))))
              (else (cons (car lat) (multiinsertR new old (cdr lat)))))))

> (multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
>(multiinsertR 'bag 'cup '(coffee cup tea cup and hick cup))
> (multiinsertR 'bag 'cup '(cup tea cup and hick cup))
> >(multiinsertR 'bag 'cup '(tea cup and hick cup))
> > (multiinsertR 'bag 'cup '(cup and hick cup))
> > >(multiinsertR 'bag 'cup '(and hick cup))
> > > (multiinsertR 'bag 'cup '(hick cup))
> > > >(multiinsertR 'bag 'cup '(cup))
> > > > (multiinsertR 'bag 'cup '())
< < < < '()
< < < <'(cup bag)
< < < '(hick cup bag)
< < <'(and hick cup bag)
< < '(cup bag and hick cup bag)
< <'(tea cup bag and hick cup bag)
< '(cup bag tea cup bag and hick cup bag)
<'(coffee cup bag tea cup bag and hick cup bag)
'(coffee cup bag tea cup bag and hick cup bag)

\end{verbatim}

\begin{verbatim}
    (define multiinsertL
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? old (car lat))
               (cons new (cons (car lat) (multiinsertL new old (cdr lat)))))
              (else (cons (car lat) (multiinsertL new old (cdr lat)))))))

    > (multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
>(multiinsertL 'bag 'cup '(coffee cup tea cup and hick cup))
> (multiinsertL 'bag 'cup '(cup tea cup and hick cup))
> >(multiinsertL 'bag 'cup '(tea cup and hick cup))
> > (multiinsertL 'bag 'cup '(cup and hick cup))
> > >(multiinsertL 'bag 'cup '(and hick cup))
> > > (multiinsertL 'bag 'cup '(hick cup))
> > > >(multiinsertL 'bag 'cup '(cup))
> > > > (multiinsertL 'bag 'cup '())
< < < < '()
< < < <'(bag cup)
< < < '(hick bag cup)
< < <'(and hick bag cup)
< < '(bag cup and hick bag cup)
< <'(tea bag cup and hick bag cup)
< '(bag cup tea bag cup and hick bag cup)
<'(coffee bag cup tea bag cup and hick bag cup)
'(coffee bag cup tea bag cup and hick bag cup)

\end{verbatim}

\begin{verbatim}
    (define multisubst
      (lambda (new old lat)
        (cond ((null? lat) (quote ()))
              ((eq? (car lat) old) (cons new (multisubst new old (cdr lat))))
              (else (cons (car lat) (multisubst new old (cdr lat)))))))

> (multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
>(multisubst 'bag 'cup '(coffee cup tea cup and hick cup))
> (multisubst 'bag 'cup '(cup tea cup and hick cup))
> >(multisubst 'bag 'cup '(tea cup and hick cup))
> > (multisubst 'bag 'cup '(cup and hick cup))
> > >(multisubst 'bag 'cup '(and hick cup))
> > > (multisubst 'bag 'cup '(hick cup))
> > > >(multisubst 'bag 'cup '(cup))
> > > > (multisubst 'bag 'cup '())
< < < < '()
< < < <'(bag)
< < < '(hick bag)
< < <'(and hick bag)
< < '(bag and hick bag)
< <'(tea bag and hick bag)
< '(bag tea bag and hick bag)
<'(coffee bag tea bag and hick bag)
'(coffee bag tea bag and hick bag)

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item Method to generate lists by using \texttt{cons} in recursions.
\end{itemize}

\newpage

\section{Numbers Games}
\label{sec:orgd22275d}

This chapter explains how numbers can be built with recursion.

\vspace{1em}

Key Takeaway:
\emph{The First Commandment (first revision): When recurring on a list of atoms, \texttt{lat}, asks two questions about it: \texttt{(null? lat)} and \texttt{else}. When
recurring on a number, \texttt{n}, ask two questions about it: \texttt{(zero? n)} and \texttt{else}.}
\vspace{0.5em}
\emph{The Fourth Commandment (first revision): Always change one argument while recurring. It must be changed closer to termination. The changing
argument must be tested in the termination condition: when using \texttt{cdr} test termination with null? and when using \texttt{sub1}, test termination with \texttt{zero?}.}
\vspace{0.5em}
\emph{The Fifth Commandment: When building a value with \texttt{+}, always use 0 for the value of the terminating line, for adding 0 does not change the
value of an addition. When building a value with \texttt{x}, always use 1 for the value of the terminating line, for multiplying by 1 does not change the value of a multiplication. When building a value with \texttt{cons}, always consider \texttt{()} for the value of the terminating line.}

\vspace{1em}

\begin{itemize}
\item In this chapter we are focusing on only the elements in the set of whole numbers.
\item We define the basic primitive functions to add 1 or subtract 1. Using this increment or decrement my assumption is we will create the Whole
number set.
\begin{verbatim}
(define add1
  (lambda (n)
    (+ n 1)))

(define sub1
  (lambda (n)
    (- n 1)))

\end{verbatim}
If we do \texttt{(sub1 0)} we will actually get \texttt{-1} but for the sake of the book we will deal only with non-negative integers.
\item \texttt{zero?} is an inbuilt predicate just like \texttt{ZEROP} in Common Lisp.
\item We define addition of two numbers by making a decrementing counter of one of the numbers till it reaches zero. For every decrement we \texttt{add1}
to the other number. So for instance we need to add 3 to 2 then the 3 goes to 2 then 1 then 0. So there are three steps 3 to 2, 2 to 1 and 1
to 0. So these three steps gets added to 2. Thus we get 5. Better to look at the stack trace for the example below. We are using the letter \texttt{o}
to denote that its our `own' definition.
\begin{verbatim}
(define o+
  (lambda (n m)
    (cond ((zero? m) n)
          (else (add1 (o+ n (sub1 m)))))))

\end{verbatim}

\begin{verbatim}
> (o+ 2 3)
>(o+ 2 3)
> (o+ 2 2)
> >(o+ 2 1)
> > (o+ 2 0)
< < 2
< <3
< 4
<5
5

\end{verbatim}
\item In the earlier chapter the authors had referred to using \texttt{(null?)} as the first test and now they correctly say that for numbers we can
use \texttt{zero?} as the test.
\item \texttt{zero?} is like \texttt{null?} and \texttt{add1} is like \texttt{cons}
\item Exactly like \texttt{o+} we can build \texttt{o-} . The only difference is that we do not \texttt{add1} on every decrement but rather subtract using \texttt{sub1}. Looking
at the stack trace below.
\begin{verbatim}
(define o-
  (lambda (n m)
    (cond ((zero? m) n)
          (else (sub1 (o- n (sub1 m)))))))

\end{verbatim}
\end{itemize}


\begin{verbatim}
> (o- 5 3)
>(o- 5 3)
> (o- 5 2)
> >(o- 5 1)
> > (o- 5 0)
< < 5
< <4
< 3
<2
2

\end{verbatim}
\begin{itemize}
\item Tuple is defined as a list of numbers. In this case I am assuming non negative numbers and also the book say an empty list will be also a
tuple. I don't think tuple is defined formally in the R\textsuperscript{5}RS standard.
\item \texttt{()} is also a tuple as it is a list of zero numbers.
\item \texttt{addtup} is essentially a function which does digit-sum (sums the numbers in the tuple).
\item We will use \texttt{o+} to build numbers just like \texttt{cons} is used to build lists.
\item Writing \texttt{addtup} seems easy given the exercises prior to this and reading Touretzky. Side comment: This book is actually really fun!
\begin{verbatim}
    (define addtup
      (lambda (tup)
        (cond ((null? tup) 0)
              (else (o+ (car tup) (addtup (cdr tup)))))))

> (addtup '(1 2 3 4 5 6 7 8 9 10))
>(addtup '(1 2 3 4 5 6 7 8 9 10))
> (addtup '(2 3 4 5 6 7 8 9 10))
> >(addtup '(3 4 5 6 7 8 9 10))
> > (addtup '(4 5 6 7 8 9 10))
> > >(addtup '(5 6 7 8 9 10))
> > > (addtup '(6 7 8 9 10))
> > > >(addtup '(7 8 9 10))
> > > > (addtup '(8 9 10))
> > > > >(addtup '(9 10))
> > > > > (addtup '(10))
> > > >[10] (addtup '())
< < < <[10] 0
< < < < < 10
< < < < <19
< < < < 27
< < < <34
< < < 40
< < <45
< < 49
< <52
< 54
<55
55

\end{verbatim}
\item Multiplication is repetitive addition. So to build \texttt{x} we have to decrement one number and for every decrement add the other number to itself.
\begin{verbatim}
    (define x
      (lambda (n m)
        (cond ((zero? m) 0)
              (else (o+ n (x n (sub1 m)))))))

> (x 4 3)
>(x 4 3)
> (x 4 2)
> >(x 4 1)
> > (x 4 0)
< < 0
< <4
< 8
<12
12

\end{verbatim}
\item A nice expansion in the book is for \texttt{(x 12 3)} fairly similar to the \texttt{trace} Dr Racket generates
\begin{verbatim}
(x 12 3)
= 12 + (x 12 2)
= 12 + 12 + (x 12 1)
= 12 + 12 + 12 + (x 12 0)
= 12 + 12 + 12 + 0
= 12 + 24
= 36

\end{verbatim}
\item A question is asked why is 0 the value for the terminal condition line in \texttt{x} and the answer to this is because 0 will not affect \texttt{+}. That
is \texttt{n + 0 = n}. The actual math behind lies in abstract algebra. In an operation such as \texttt{+} there is a concept of identity and inverse. The
\texttt{identity} or \texttt{neutral} element in the set of this operation does not affect the value of other elements when the operation is applied between
an element and this identity. For example, in the operation of \texttt{+} the \texttt{identity} element is \texttt{0}. The operation \texttt{+} say is applied to the set
of non-negative numbers (as done in this book). So \texttt{+} 2 and the \texttt{identity} should yield 2 itself. Thus the identity in this set of whole
numbers for this specific \texttt{+} operation is 0. Similarly for the operation of \texttt{x} in the set of natural numbers the identity is 1. 2 multiplied
by 1 yields 2 again. Now we get back to scheme and away from abstract algebra.
\item The next function we write is addition of two tuples. In this all elements in the tuple at their respective positions are added. The first version
of the code adds two tuples of the same length (code is below). When we supply it with varying length tuples we get an error because it tries to
add a number to an empty list. The trace diagram shows the error. Now we will write a cleaner function which will take varying length tuples.
\begin{verbatim}
; this v1 version will work only if length of tup1 and tup2 is same
    (define tup+v1       
      (lambda (tup1 tup2)
        (cond ((and (null? tup1) (null? tup2)) (quote ()))
              (else (cons (o+ (car tup1) (car tup2))
                          (tup+v1 (cdr tup1) (cdr tup2)))))))

> (tup+v1 '(1 2 3 4) '(4 3 2 1))
>(tup+v1 '(1 2 3 4) '(4 3 2 1))
> (tup+v1 '(2 3 4) '(3 2 1))
> >(tup+v1 '(3 4) '(2 1))
> > (tup+v1 '(4) '(1))
> > >(tup+v1 '() '())
< < <'()
< < '(5)
< <'(5 5)
< '(5 5 5)
<'(5 5 5 5)
'(5 5 5 5)

> (tup+v1 '(1 2 3 4) '(4 3 2))
>(tup+v1 '(1 2 3 4) '(4 3 2))
> (tup+v1 '(2 3 4) '(3 2))
> >(tup+v1 '(3 4) '(2))
> > (tup+v1 '(4) '())
. . car: contract violation
  expected: pair?
  given: '()

\end{verbatim}
\item \texttt{tup+} below is the correct way to define addition of the elements of two tuples. The trace diagram helps understand why. When one of the tuples
runs out of elements i.e. it is an empty tuple, then at that time whatever the present recurring state of the other tuple is that is used for
\texttt{cons}-ing when the stack frames start returning values.
\begin{verbatim}
    (define tup+
      (lambda (tup1 tup2)
        (cond ((null? tup1) tup2)
              ((null? tup2) tup1)
              (else (cons (o+ (car tup1) (car tup2))
                          (tup+ (cdr tup1) (cdr tup2)))))))

> (tup+ '(1 2 3 4) '(4 3 2 1))
>(tup+ '(1 2 3 4) '(4 3 2 1))
> (tup+ '(2 3 4) '(3 2 1))
> >(tup+ '(3 4) '(2 1))
> > (tup+ '(4) '(1))
> > >(tup+ '() '())
< < <'()
< < '(5)
< <'(5 5)
< '(5 5 5)
<'(5 5 5 5)
'(5 5 5 5)

> (tup+ '(1 2 3 ) '(4 3 2 1))
>(tup+ '(1 2 3) '(4 3 2 1))
> (tup+ '(2 3) '(3 2 1))
> >(tup+ '(3) '(2 1))
> > (tup+ '() '(1))
< < '(1)
< <'(5 1)
< '(5 5 1)
<'(5 5 5 1)
'(5 5 5 1)

> (tup+ '(1 2 3 4) '(4 3 2))
>(tup+ '(1 2 3 4) '(4 3 2))
> (tup+ '(2 3 4) '(3 2))
> >(tup+ '(3 4) '(2))
> > (tup+ '(4) '())
< < '(4)
< <'(5 4)
< '(5 5 4)
<'(5 5 5 4)
'(5 5 5 4)

\end{verbatim}
\item Definitions of greater than and smaller than \texttt{>} and \texttt{<} is tricky. For greater than \texttt{>} the order of tests  matter. The \texttt{\#f} needs to
be tested first for the base condition. This is so because when \texttt{n} reaches zero we know for sure that \texttt{n} is \texttt{<= m} thus the overall test
is \texttt{\#f}. But if we had tested \texttt{m} as zero which would return \texttt{\#t} even if the condition \texttt{=} is satisfied. Similarly we can compose a function
for lesser than \texttt{<}
\begin{verbatim}
    (define >
      (lambda (n m)
        (cond ((zero? n) #f)
              ((zero? m) #t)
              (else (> (sub1 n) (sub1 m))))))
> (> 3 1)
>(> 3 1)
>(> 2 0)
<#t
#t

> (> 1 4)
>(> 1 4)
>(> 0 3)
<#f
#f

> (> 4 4)
>(> 4 4)
>(> 3 3)
>(> 2 2)
>(> 1 1)
>(> 0 0)
<#f
#f

\end{verbatim}

\begin{verbatim}
    (define <
      (lambda (n m)
        (cond ((zero? m) #f)
              ((zero? n) #t)
              (else (< (sub1 n) (sub1 m))))))

> (< 1 4)
>(< 1 4)
>(< 0 3)
<#t
#t
> (< 4 1)
>(< 4 1)
>(< 3 0)
<#f
#f
> (< 4 4)
>(< 4 4)
>(< 3 3)
>(< 2 2)
>(< 1 1)
>(< 0 0)
<#f
#f

\end{verbatim}
\item Next we compose the equality function \texttt{=} for numbers. The plain vanilla method is to check if one is zero and whether at the same time the
other is zero too. If not then it is false. Also if one reaches zero while decrementing and the other is still not zero then it is not equal.
The code is simple below. The other way which build up on \texttt{>} and \texttt{<} is to check if these two are false then \texttt{=} will be true.
\begin{verbatim}
(define o=
  (lambda (n m)
    (cond ((zero? m) (zero? n))
          ((zero? n) #f)
          (else (= (sub1 n) (sub1 m))))))

(define =
  (lambda (n m)
    (cond ((> n m) #f)
          ((< n m) #f)
          (else #t))))

\end{verbatim}
\item Exponents (or raising to power) is also simple.
\begin{verbatim}
    (define o-exp
      (lambda (n m)
        (cond ((zero? m) 1)
              (else (x n (o-exp n (sub1 m)))))))

> (o-exp 2 4)
>(o-exp 2 4)
> (o-exp 2 3)
> >(o-exp 2 2)
> > (o-exp 2 1)
> > >(o-exp 2 0)
< < <1
< < 2
< <4
< 8
<16
16

\end{verbatim}

\item Integer division is implemented smartly by basically figuring out the how many wholes of a number fits into another. Thus discarding any of the
remainder. Wonder how remainder can be obtained via recursion especially for recurring decimals or if I throw an irrational number.
\begin{verbatim}
    (define o-div
      (lambda (n m)
        (cond ((< n m) 0)
              (else (add1 (o-div (o- n m) m))))))
> (o-div 16 3)
>(o-div 16 3)
> (o-div 13 3)
> >(o-div 10 3)
> > (o-div 7 3)
> > >(o-div 4 3)
> > > (o-div 1 3)
< < < 0
< < <1
< < 2
< <3
< 4
<5
5

\end{verbatim}
\end{itemize}






































\newpage

\section{* Oh My Gawd *: It's Full of Stars}
\label{sec:orgcd99708}

\newpage

\section{Shadows}
\label{sec:org8b7bb4c}

\newpage

\section{Friends and Relations}
\label{sec:orgfb4b8a2}

\newpage

\section{Lambda the Ultimate}
\label{sec:orgd84a2fd}

\newpage

\section{\ldots{} and Again, and Again, and Again, \ldots{}}
\label{sec:orge3a267f}

\newpage

\section{What Is the Value of All of This?}
\label{sec:orgca0aa53}

\newpage

\section{Intermission}
\label{sec:org83c9172}

\newpage

\section{The Ten Commandments}
\label{sec:org5f4ae2e}

\newpage

\section{The Five Rules}
\label{sec:org8c0ab25}

\newpage
\end{document}
