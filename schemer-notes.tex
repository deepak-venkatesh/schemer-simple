% Created 2025-10-11 Sat 11:11
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setlength{\parindent}{0pt}
\author{Deepak Venkatesh}
\date{\today}
\title{The Little Schemer Simplified}
\hypersetup{
 pdfauthor={Deepak Venkatesh},
 pdftitle={The Little Schemer Simplified},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\textbf{Note:}

\vspace{1em}

These are my personal notes created to deepen my understanding of Lisp and programming in general. `The Little Schemer'
(4th edition) by Daniel Friedman and Matthias Felleisen is a remarkable book that teaches programming concepts in a
unique and playful way. It builds from first principles using only a small set of primitives, showing how powerful
ideas — such as recursion, functional programming, lambda functions, and interpreters—can be expressed using just
those few building blocks. I am making this public since other beginners could benefit from these notes.

While the book uses Scheme, I prefer to work in Common Lisp and have adapted the examples accordingly. Despite its
lighthearted tone, the book is far from an easy read — it demands close attention and careful thought. My advice to
anyone who wants to learn lisp is to work through David Touretzky's book titled `Common Lisp A Gentle Introduction to
Symbolic Computing' (2nd ed.). It's a great first book for introduction to programming not just Lisp.

All mistakes in these notes, whether typographical or conceptual, are entirely my own. Any misinterpretations are as
well. I am still new to both Lisp and programming.

\vspace{1em}

\emph{Hardware and Software used for this study}
\begin{itemize}
\item Common Lisp SBCL version 2.4.1
\item emacs
\item slime for emacs
\item Macbook Pro 2019 2.6 Ghz I7 Intel chip with 16 GB RAM
\end{itemize}

\newpage
\section{Foreword}
\label{sec:org79e8220}

By Gerald Sussman of MIT, co-author of the book SICP (the wizard book).

\vspace{1em}

Key Takeaway:
\emph{In order to be creative one must first gain control of the medium.}

\vspace{1em}

\begin{itemize}
\item Core skills are the first set of things required to master any pursuit.
\item Deep understanding is required to visualize beforehand the program which will be written.
\item Lisp provides freedom and flexibility (this is something which will only come in due course of time, as we keep
learning more about programming).
\item Lisp was initially conceived as a theoretical vehicle for recursion and symbolic algebra (this is the algebra we
have been taught in school such as \((a + b)^2 = a^2 + b^2 + 2ab\)).
\item In Lisp procedures are first class. Procedures are essentially a `variant' of functions. A mathematical function maps
a given input to an output (domain - range/co-domain) but a procedure is a process to arrive at the result via
computation.
\item First Class basically means that the procedure itself can be passed around as arguments to other procedures.
Procedures can be return values. They can also be stored in data structures. A similar corollary (though not exact)
are composite functions which are usually taught in pre-calculus.
\item Lisp programs can manipulate representations of Lisp programs - this likely refers to macros and how in Lisp code can
be treated as data.
\end{itemize}

\newpage
\section{Preface}
\label{sec:orgf6ad534}

Key Takeaway:
\emph{The goal of the book is to teach the reader to think recursively.}

\vspace{1em}

\begin{itemize}
\item Programs take data, apply a process on that data, and then produce some data.
\item Recursion is the act of defining an object or solving a problem in terms of itself.
\item The authors believe that writing programs recursively in Lisp is essentially pattern recongnition. Well I think
it's true for any programming language or any programming paradigm.
\item For recursive programming and studying, this book we will need only a few Common Lisp primitives, namely:
\begin{itemize}
\item \texttt{CAR}
\item \texttt{CDR}
\item \texttt{CONS}
\item \texttt{ATOM} (\texttt{ATOM?} actually which is not a primitive in Common Lisp but explanation below)
\item \texttt{EQ}, \texttt{EQL}, \texttt{EQUAL}, \texttt{EQUALP} (currently unsure if all or only a few will be used)
\item \texttt{NULL}, \texttt{ZEROP}, \texttt{NUMBERP}
\item \texttt{ADD1}, \texttt{SUB1} (these do not exist in Common Lisp, we will define them when needed)
\item \texttt{AND}, \texttt{OR}
\item \texttt{LAMBDA}
\item \texttt{COND}
\item \texttt{DEFUN}
\end{itemize}
\item The definitions of the above primitives I am not outlining here and will come to it as we work through the book.
\item Authors advise to read this book slowly. Very slowly and delibrately. Re-read it multiple times. Every concept
should be clear before going onto the next page.
\item In the preface we hit the first difference between Scheme and Common Lisp. \texttt{()} in Scheme is actually different
from that in Common Lisp. Scheme considers \texttt{()} as only a list and not an atom. While in Common Lisp \texttt{()} is
considered both an atom and a list. Therefore, to stay with the theme of this book we will define our own
predicate \texttt{ATOM?} in Common Lisp which will work like the \texttt{atom?} in Scheme. \texttt{ATOM} is defined as per the Lisp
Hyperspec as well as Common Lisp The Language (2nd ed.) by Guy Steele as `The predicate \texttt{ATOM} is trye if its
argument is not a \texttt{CONS}, and otherwise is false. In SBCL  \texttt{ATOM} will give \texttt{T}

\begin{verbatim}
(atom '())
» T
\end{verbatim}

We define our own predicate \texttt{ATOMP}

\begin{verbatim}
(defun atom? (x)
  (not (listp x)))
\end{verbatim}

So now \texttt{ATOMP} for our studies of this book will give \texttt{NIL} when tested for an empty list \texttt{'()}

\begin{verbatim}
(atom? '())
» NIL
\end{verbatim}

\item There is another predicate in Common Lisp \texttt{CONSP}. This tests whether the argument to the predicate has a \texttt{CONS}
cell or not. But when we check for a \texttt{CONS} cell for an empty list \texttt{()} then \texttt{CONSP} returns \texttt{NIL}. This perhaps
means that the empty list in this case is being treated as an \texttt{ATOM}.
\end{itemize}



\newpage
\section{Toys}
\label{sec:org91cdc1e}

This chapter introduces primitives of Lisp. These are the basic building blocks.

\subsection{The Law of \texttt{CAR}}
\label{sec:orgb4a418c}
Key Takeaway:
\emph{The primitive \texttt{CAR} is defined only for non-empty lists. The \texttt{CAR} is the first atom (element) of that list.}
\emph{But in Common Lisp the \texttt{CAR} of an empty list will give \texttt{NIL}.}

\vspace{1em}

\begin{itemize}
\item In Common Lisp an \texttt{ATOM} is anything which is not a \texttt{CONS}.
\item \texttt{ATOM} will include single characters, strings, numbers, special characters.
\item Anything enclosed in parenthesis/brackets \texttt{()} is a list.
\item We can have nested lists which are also called improper lists and non-nested lists which are proper lists.
\item An S-expression which stands for Symbolic Expression is any Lisp object that can be read and evaluated by the
Lisp reader. S-expressions include both \texttt{ATOM} and \texttt{CONS} (which is used to make lists).
\item Q. How many S-expressions are in the list \texttt{(how are you doing so far)} and what are they? The book answers 6 and
those are the elements in the lists, basically the 6 atoms inside the list. But the list itself is an S-expression
in Common Lisp so there are actually 7 S-expressions.
\item The next 2 questions build up on this contradiction in my opinion. A question asks how many S-expressions are in the
list \texttt{(((how) are) ((you) (doing so)) far)} and gives the answer as 3. It refers to the 3 lists inside the outermost
list. So a list is an S-expression for this question but a list was not an S-expression for the prior question.
Furthermore 3 should not be the correct answer here. The answer should be 12 in my opinion - 6 atoms (the words),
6 lists (nested and outermost).
\item The difference of \texttt{()} again comes up since it is both a list and an atom in Common Lisp unlike Scheme. The \texttt{CAR}
of \texttt{()} will be \texttt{NIL} in Common Lisp unlike Scheme. In Common Lisp as per the standards and empty list's \texttt{CAR} and
\texttt{CDR} are both \texttt{NIL}.
\begin{verbatim}
(car ())
» NIL
\end{verbatim}
\item \texttt{CAR} is the first atom/element of a list. If we try to find the \texttt{CAR} of a string of character or numbers SBCL will
give us a variable unbound error or say that the number is not of the type list.
\end{itemize}


\subsection{The Law of \texttt{CDR}}
\label{sec:orgeeb14db}
Key Takeaway:
\emph{The primitive \texttt{CDR} is defined only for non-empty lists. The \texttt{CDR} of any non-empty list is always another list.}
\emph{The \texttt{CDR} of an empty list in Common Lisp is \texttt{NIL}.}

\vspace{1em}

\begin{itemize}
\item The book says \texttt{CAR} of \emph{l} is same as \texttt{(car l)}. Similarly for \texttt{CDR}.
\item \texttt{CDR} of a single atom/element list is \texttt{NIL} or \texttt{()}.
\item In Tourtezky's book there is a tool called SDRAW. It allows us to do draw \texttt{CONS} cell structures with the \texttt{CAR} \&
\texttt{CDR} pointers. I have uploaded the code for this tool on Github \href{https://github.com/deepak-venkatesh/sdraw}{here}. For \texttt{(car a)} and \texttt{(cdr a)} where \texttt{a} is
\texttt{samosa} will be represented as:

\texttt{[*|*]-{}-{}-> NIL} \(\newline\)
\texttt{|} \(\newline\)
\texttt{|} \(\newline\)
\texttt{V} \(\newline\)
\texttt{SAMOSA}

\item \texttt{CDR} of an empty list will be \texttt{NIL} as per Common Lisp standards.
\end{itemize}


\subsection{The Law of \texttt{CONS}}
\label{sec:orgfa02c4c}
Key Takeaway:
\emph{The primitive \texttt{CONS} takes two arguments. The second argument to \texttt{CONS} must be a list. The result is a list.}

\vspace{1em}

\begin{itemize}
\item \texttt{CONS} actually creates a \texttt{CONS} cell. The \texttt{CAR} of which is the first input to \texttt{CONS} and the \texttt{CDR} is pointed to
the second input. The return value of the \texttt{CONS} is a pointer to it. Refer Touretzky's Chapter 2, clearly explained.
\item Q. What is \texttt{(cons s l)} where \texttt{s} is \texttt{((a b c))} and \texttt{l} is \texttt{b}? This brings in the topic of Dotted Lists. In a
proper list the chain of \texttt{CONS} cells ends with \texttt{NIL} as the atom, meaning the last cell points to a \texttt{NIL} but in a
dotted list the last atom points to a non \texttt{NIL} atom. In the above case we will get the following:
\begin{verbatim}
(cons '((a b c)) 'b)
» (((A B C)) . B)
\end{verbatim}
\end{itemize}


\subsection{The Law of \texttt{NULL}}
\label{sec:org554e6cc}
Key Takeaway:
\emph{The primitive \texttt{NULL} is defined only for lists.}

\vspace{1em}

\begin{itemize}
\item Q. Is it true that the list \texttt{l} is the null list where \texttt{l} is \texttt{()}? Yes, but not because it is the list composed of
zero S-expressions but because the list \emph{contains} zero S-expressions. In Common Lisp we don't use \texttt{?} at the end
of predicates. So it is \texttt{NULL} in Common Lisp and \texttt{null?} in Scheme.
\item Another difference in Common Lisp and Scheme is how they refer to False. In scheme it is explicitly \texttt{\#t} or \texttt{\#f} but
in Common Lisp it is \texttt{T} for True or else it is \texttt{NIL} which means False. A section of notes on only \texttt{NIL} follows
the end of this chapter.
\begin{verbatim}
(null '(gol gappa))
» NIL

(null '())
» T
\end{verbatim}
\item \texttt{NULL} of an atom will throw a variable unbound error for a string or say the number is not of the type list.
\end{itemize}


\subsection{The Law of \texttt{EQ}}
\label{sec:org89e8fab}
Key Takeaway:
\emph{The function \texttt{EQ} in Common Lisp takes two arguments and compares the unique address of these two arguments.}

\vspace{1em}

\begin{itemize}
\item Now there are major difference here between the ways in which equality can be tested. First in Common Lisp symbols
are unique where one symbol can have only address in computer's memory (within a given package in Common Lisp).
This address of the symbol object is unique. So if we have a list as \texttt{(TIME AFTER TIME)} then \texttt{TIME} has the address
irrespective of the fact that it is repeated twice. The \texttt{EQ} function does this. This is a deviation from the
\texttt{eq?} as defined in the book.
\item Common Lisp has other equality tests
\begin{itemize}
\item \texttt{EQ}: As explained above
\item \texttt{EQL}: Same as \texttt{EQ} but for two numbers it will compare the values. So integer 4 is different from a floating
point 4.0
\item \texttt{EQUAL}: This compares the elements of a list one by one. It is slower than \texttt{EQ}
\item \texttt{EQUALP}: Same as \texttt{EQUAL} but ignores case
\item \texttt{=} Only for number comparison. Integer 4 and floating point 4.0 yields \texttt{T}
\end{itemize}
\item We again come across the treatment of \texttt{()} differently in Scheme and Common Lisp. In Scheme \texttt{()} is only a list and
not an atom but in Common Lisp it is both.
\item One key point to note is that \texttt{EQ} is a function and not a primitive predicate in Common Lisp. We can verify this
\begin{verbatim}
(functionp #'eq)
» T
\end{verbatim}
\item The book states that two lists can be compared using \texttt{eq?}. In Common Lisp \texttt{EQ} function will indeed compare two
lists but even if they contain same elements the lists could be distinct an thus \texttt{EQ} will return a \texttt{NIL}. Here if
the intent is to compare the contents in the list then we need to use \texttt{EQUAL}.
\begin{verbatim}
(setf mithai (list 'ladoo 'barfi 'jalebi))
(setf sweets (list 'ladoo 'barfi 'jalebi))
(equal mithai sweets)
 » T
(eq mithai sweets)
 » NIL
\end{verbatim}
\item Numbers can also be compared using \texttt{EQ} since it will check their memory addresses.
\end{itemize}

\subsection{Notes on \texttt{NIL} in Common Lisp}
\label{sec:orgdad7046}
\vspace{1em}

\begin{itemize}
\item Predicates are functions that answer questions in \texttt{T} or \texttt{NIL} (anything non-NIL is equivalent to \texttt{T}).
\item \texttt{NIL} is the only way to say ‘no’ in Lisp. For instance the \texttt{NOT} predicate will return \texttt{NIL} for every input
except \texttt{NIL} itself.
\item A function is said to return ‘false’ when it returns \texttt{NIL}. But the function is said to return ‘true’ when it
returns anything other than \texttt{NIL}.
\item Anything other than \texttt{NIL} is treated as true in Lisp.
\item A list of zero elements is called an empty list (do not use the term set). It has no cons cells. Denoted by empty
brackets \texttt{()}.
\item In the computer \texttt{()} i.e. empty list is represented by the symbol \texttt{NIL}.
\item The symbol \texttt{NIL} is the empty list \texttt{()}. Thus, \texttt{NIL} is used to mark the end of a \texttt{CONS} cell chain.
\item In bracket notation \texttt{NIL} at the end of the \texttt{CONS} chain is omitted as a convention.
\item Since \texttt{NIL} and \texttt{()} are same they can be written interchangeably. Therefore, \texttt{(A () B)} is same as \texttt{(A NIL B)}
\item The length of the empty list is 0. \texttt{NIL} can be passed to \texttt{LENGTH} since it is an empty list.
\item \texttt{NIL} is the only thing which is a symbol and a list.
\item The \texttt{CAR} and \texttt{CDR} of \texttt{NIL} is \texttt{NIL}.
\item \texttt{NIL} like \texttt{T}, characters and numbers evaluates to itself. This is so because their value cells point to
themselves.
\item Explicit use as a symbol can be done by quoting i.e. \texttt{‘NIL}
\item Historically empty list was treated as false.
\end{itemize}

The 5 pointers of the symbol \texttt{NIL}
\begin{itemize}
\item Name: \texttt{NIL}
\item Value: \texttt{NIL} (Thus it is self evaluating. The pointer from value of \texttt{NIL} goes back to the symbol \texttt{NIL} itself.
Same with \texttt{T})
\item Function: No associated function
\item plist: No associated properties
\item Package: In Common Lisp Package
\end{itemize}


\newpage
\section{Do It, Do It Again, and Again, and Again \ldots{}}
\label{sec:org0c91591}

This chapter explains recursion. The best material for recursion in my opinion is Chapter 8 in  Touretzky's book.

Key Takeaway:
\emph{The First Commandment (preliminary): Always ask \texttt{NULL} as the first question in expressing a function}

\vspace{1em}
\begin{itemize}
\item After reading Touretzky's chapter on recursion this chapter will feel very easy. Also the first commandment is not
really true. Sometimes in recursion the first question is not necessarily \texttt{NULL}. Let's use an example. Make a
recursive  function to compute a factorial of a number.
\begin{verbatim}
(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))
\end{verbatim}
Here the first question actually asks whether the argument \texttt{n} is a zero or not.
\item The chapter introduces a function named \texttt{LAT?}. It stands for a \texttt{list of atoms}. This means every element of the
list is an \texttt{ATOM?}. We will use our own defined \texttt{ATOMP} predicate so that we do not return \texttt{T} for a \texttt{()}.
\item Recursive function definition of \texttt{LAT?} in Common Lisp.
\begin{verbatim}
(defun lat? (l)
  (cond ((null l) t)
        ((atom? (car l)) (lat? (cdr l)))
        (t nil)))
\end{verbatim}
\item It is important to understand how \texttt{COND} functions. Well \texttt{COND} is actually a macro. This macro has a series of
tests and results. The macro goes from top to bottom. The cases are processed from left to right under each test.
Technically we can have more than one result per test for evaluation. As a Common Lisp `trick' the last test is
usually a \texttt{T} which evaluates to \texttt{TRUE} always and hence the last result is returned. \texttt{COND} is a very nice way to
do implement \texttt{If..then..Else}. I have never seen such seamless conditional in any language yet.
\item \texttt{LAT} basically is a \texttt{COND} which keeps checking through all the elements of a list to test for \texttt{ATOM?} till the
list ends. It checks \texttt{CAR} one by one for each subsequent \texttt{CDR} for \texttt{ATOMP}.
\item I would study Chapter 8 of Touretzky for getting the intuition on recursion right. The author has done a great job.
\item SBCL comes with an inbuilt tool called \texttt{TRACE} which lets us see the actual function calls. So lets trace all the
recursive examples in this chapter.
\begin{verbatim}
CL-USER> (lat? '(Jack Sprat could eat no chicken fat))
  0: (LAT? (JACK SPRAT COULD EAT NO CHICKEN FAT))
    1: (LAT? (SPRAT COULD EAT NO CHICKEN FAT))
      2: (LAT? (COULD EAT NO CHICKEN FAT))
        3: (LAT? (EAT NO CHICKEN FAT))
          4: (LAT? (NO CHICKEN FAT))
            5: (LAT? (CHICKEN FAT))
              6: (LAT? (FAT))
                7: (LAT? NIL)
                7: LAT? returned T
              6: LAT? returned T
            5: LAT? returned T
          4: LAT? returned T
        3: LAT? returned T
      2: LAT? returned T
    1: LAT? returned T
  0: LAT? returned T
T
\end{verbatim}

\item 
\end{itemize}









































\section{Cons the Magnificient}
\label{sec:orgad8fc99}

\section{Numbers Games}
\label{sec:orgcffea2d}

\section{* Oh My Gawd *: It's Full of Stars}
\label{sec:org2cfa03c}

\section{Shadows}
\label{sec:org8b46543}

\section{Friends and Relations}
\label{sec:orgac2d29f}

\section{Lambda the Ultimate}
\label{sec:orgaa80ecb}

\section{\ldots{} and Again, and Again, and Again, \ldots{}}
\label{sec:org2d856b4}

\section{What Is the Value of All of This?}
\label{sec:org154f2bc}

\section{Intermission}
\label{sec:org8e01e75}

\section{The Ten Commandments}
\label{sec:orgdde5cf8}

\section{The Five Rules}
\label{sec:org2cf01a8}
\end{document}
