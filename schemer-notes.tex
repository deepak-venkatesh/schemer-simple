% Created 2025-10-17 Fri 11:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\setlength{\parindent}{0pt}
\author{Deepak Venkatesh}
\date{\today}
\title{The Little Schemer Simplified}
\hypersetup{
 pdfauthor={Deepak Venkatesh},
 pdftitle={The Little Schemer Simplified},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.6.15)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\newpage
\textbf{Note:}

\vspace{1em}

These are my personal notes created to deepen my understanding of Lisp and programming in general. `The Little Schemer'
(4th edition) by Daniel Friedman and Matthias Felleisen is a remarkable book that teaches programming concepts in a
unique and playful way. It builds from first principles using only a small set of primitives, showing how powerful
ideas — such as recursion, functional programming, lambda functions, and interpreters — can be expressed using just
those few building blocks. I am making this public since other beginners could benefit from these notes.

While the book uses Scheme, I initially worked it out using Common Lisp and had adapted the examples accordingly. Now
I am working through it using Racket, a modern descendent of Scheme. Despite its lighthearted tone, the book is far
from an easy read — it demands close attention and careful thought. My advice to anyone who wants to learn lisp is to
first work through Professor David Touretzky's book titled `Common Lisp A Gentle Introduction to Symbolic Computing'
(2nd ed.). It's a great book for introduction to programming not just Lisp.

All mistakes in these notes, whether typographical or conceptual, are entirely my own. Any misinterpretations are as
well. I am still new to both Lisp and programming.

\vspace{1em}

\emph{Hardware and Software used for this study}
\begin{itemize}
\item Language: Racket (a Scheme)
\item Editor: Dr Racket
\item emacs for org notes
\item Macbook Pro 2019 2.6 Ghz I7 Intel chip with 16 GB RAM
\end{itemize}

\newpage
\section{Foreword}
\label{sec:org7bd9b0d}

By Gerald Sussman of MIT, co-author of the book SICP (the wizard book).

\vspace{1em}

Key Takeaway:
\emph{In order to be creative one must first gain control of the medium.}

\vspace{1em}

\begin{itemize}
\item Core skills are the first set of things required to master any pursuit.
\item Deep understanding is required to visualize beforehand the program which will be written.
\item Lisp provides freedom and flexibility (this is something which will only come in due course of time, as we keep
learning more about programming).
\item Lisp was initially conceived as a theoretical vehicle for recursion and symbolic algebra (this is the algebra we
have been taught in school such as \((a + b)^2 = a^2 + b^2 + 2ab\)).
\item In Lisp procedures are first class. Procedures are essentially a `variant' of functions. A mathematical function
maps a given input to an output (domain - range/co-domain) but a procedure is a process to arrive at the result via
computation.
\item First Class basically means that the procedure itself can be passed around as arguments to other procedures.
Procedures can be return values. They can also be stored in data structures. A similar corollary (though not exact)
are composite functions which are usually taught in pre-calculus.
\item Lisp programs can manipulate representations of Lisp programs - this likely refers to macros and how in Lisp code
can be treated as data.
\end{itemize}

\vspace{1em}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item None
\end{itemize}

\newpage
\section{Preface}
\label{sec:orgd591f2d}

Key Takeaway:
\emph{The goal of the book is to teach the reader to think recursively.}

\vspace{1em}

\begin{itemize}
\item Programs take data, apply a process on that data, and then produce some data.
\item Recursion is the act of defining an object or solving a problem in terms of itself.
\item The authors believe that writing programs recursively in Lisp is essentially pattern recongnition. Well I think
it's true for any programming language or any programming paradigm.
\item For recursive programming and studying, this book we will need only a few primitives/functions, namely:
\begin{itemize}
\item \texttt{car}
\item \texttt{cdr}
\item \texttt{cons}
\item \texttt{atom?}
\item \texttt{eq?}
\item \texttt{null?}
\item \texttt{add1}, \texttt{sub1}
\item \texttt{and}, \texttt{or}
\item \texttt{else}
\item \texttt{lambda}
\item \texttt{cond}
\item \texttt{define}
\end{itemize}
\item The definitions of the above primitives I am not outlining here and will come to it as we work through the book.
\item Authors advise to read this book slowly. Very slowly and delibrately. Re-read it multiple times. Every concept
should be clear before going onto the next page.
\item In the preface we hit the first difference between Scheme and Common Lisp. \texttt{()} in Scheme is actually different
from that in Common Lisp. Scheme considers \texttt{()} as \emph{only} a list and \emph{not} an atom. While in Common Lisp \texttt{()} is
considered both an atom and a list. \texttt{ATOM} is defined as per the Lisp Hyperspec as well as Common Lisp The
Language (2nd ed.) by Guy Steele as `The predicate \texttt{ATOM} is true if its argument is not a \texttt{CONS}, and otherwise
is false. In SBCL, a Common Lisp implementation  \texttt{ATOM} will give \texttt{T}

\begin{verbatim}
(atom '())
» T

\end{verbatim}

We define our own predicate \texttt{atom?} in Scheme 

\begin{verbatim}
(define atom?
  (lambda (x)
    (and (not (pair? x)) (not (null? x)))))

\end{verbatim}

Some tests for checking \texttt{atom?} in Scheme below

\begin{verbatim}
> (atom? 'a)
#t
> (atom? (quote ()))
#f
> (atom? '(a b c))
#f
> (atom? 42)
#t

\end{verbatim}
\end{itemize}


\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item In Scheme \texttt{()} is only a list and not an atom.
\end{itemize}


\newpage
\section{Toys}
\label{sec:orge76bfce}

This chapter introduces primitives of Scheme. These are the basic building blocks.

\vspace{1em}

\subsection{The Law of \texttt{car}}
\label{sec:orga6ab9e8}
Key Takeaway:
\emph{The primitive \texttt{car} is defined only for non-empty lists. The \texttt{car} is the first atom (element) of that list.}

\vspace{1em}

\begin{itemize}
\item An atom is indivisible - number, strings
\item Anything enclosed in parenthesis/brackets \texttt{()} is a list.
\item We can have nested lists which are also called improper lists and non-nested lists which are proper lists.
\item An S-expression which stands for Symbolic Expression is any Lisp object that can be read and evaluated by the
Lisp reader.
\item Q. How many S-expressions are in the list \texttt{(how are you doing so far)} and what are they? The book answers 6 and
those are the elements in the lists, basically the 6 atoms inside the list.
\item A question asks how many S-expressions are in the list \texttt{(((how) are) ((you) (doing so)) far)} and gives the
answer as 3. It refers to the 3 lists inside the outermost list.
\item The difference of \texttt{()} again comes up since it is both a list and an atom in Common Lisp unlike Scheme. The \texttt{car}
of \texttt{()} will be \texttt{NIL} in Common Lisp unlike Scheme. In Common Lisp as per the standards and empty list's \texttt{car} and
\texttt{cdr} are both \texttt{NIL} (shown below).
\begin{verbatim}
(car ())
» NIL

\end{verbatim}
\item \texttt{car} is the first atom/element of a list. If we try to find the \texttt{car} of a string of character or numbers we will
get an error like below.
\begin{verbatim}
  > (car 'a)
. . car: contract violation
  expected: pair?
  given: 'a
> (car 42)
. . car: contract violation
  expected: pair?
  given: 42

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{cdr}}
\label{sec:org546d3ab}
Key Takeaway:
\emph{The primitive \texttt{cdr} is defined only for non-empty lists. The \texttt{cdr} of any non-empty list is always another list.}

\vspace{1em}

\begin{itemize}
\item The book says \texttt{car} of \emph{l} is same as \texttt{(car l)}. Similarly for \texttt{cdr}.
\item \texttt{cdr} of a single atom/element list is \texttt{()}.
\item In Tourtezky's book there is a tool called SDRAW. It allows us to do draw \texttt{cons} cell structures with the \texttt{car} \&
\texttt{cdr} pointers. I have uploaded the code for this tool on Github \href{https://github.com/deepak-venkatesh/sdraw}{here}. For \texttt{(car a)} and \texttt{(cdr a)} where \texttt{a} is
\texttt{samosa} will be represented as:

\texttt{[*|*]-{}-{}-> NIL} \(\newline\)
\texttt{|} \(\newline\)
\texttt{|} \(\newline\)
\texttt{V} \(\newline\)
\texttt{SAMOSA}

\item \texttt{cdr} of an empty list will be \texttt{()} as per Common Lisp standards but in Scheme it is an error.
\end{itemize}


\subsection{The Law of \texttt{cons}}
\label{sec:org6d42956}
Key Takeaway:
\emph{The primitive \texttt{cons} takes two arguments. The second argument to \texttt{cons} must be a list. The result is a list.}

\vspace{1em}

\begin{itemize}
\item \texttt{cons} actually creates a \texttt{cons} cell. The \texttt{car} of which is the first input to \texttt{cons} and the \texttt{cdr} is pointed to
the second input. The return value of the \texttt{cons} is a pointer to it. Refer Touretzky's Chapter 2, clearly explained.
\item Q. What is \texttt{(cons s l)} where \texttt{s} is \texttt{((a b c))} and \texttt{l} is \texttt{b}? This brings in the topic of Dotted Lists. In a
proper list the chain of \texttt{cons} cells ends with \texttt{()} as the atom, meaning the last cell points to a \texttt{NIL} but in a
dotted list the last atom points to a non \texttt{NIL} atom. In the above case we will get the following:
\begin{verbatim}
> (cons 'a '(b c))
'(a b c)
> (cons 'a 'b)
'(a . b)

\end{verbatim}
\end{itemize}


\subsection{The Law of \texttt{null?}}
\label{sec:orgdf3c65f}
Key Takeaway:
\emph{The primitive \texttt{null?} is defined only for lists.}

\vspace{1em}

\begin{itemize}
\item Q. Is it true that the list \texttt{l} is the null list where \texttt{l} is \texttt{()}? Yes, because it is  composed of
zero S-expressions.
\item Another difference in Common Lisp and Scheme is how they refer to False. In scheme it is explicitly \texttt{\#t} or \texttt{\#f} but
in Common Lisp it is \texttt{T} for True or else it is \texttt{NIL} which means False.
\item \texttt{null?} of an atom should throw an error for a string or a number but actually it gives \texttt{\#f} since in Scheme \texttt{null?}
for \texttt{()} is \texttt{\#t} and for everything else it is \texttt{\#f}. See code below.
\begin{verbatim}
  > (null? 'a)
#f
> (null? (quote ()))
#t

\end{verbatim}
\end{itemize}

\subsection{The Law of \texttt{eq?}}
\label{sec:org6d31b9d}
Key Takeaway:
\emph{The primitive \texttt{eq?} in takes two arguments and compares them. Each must be a non numeric atom.}

\vspace{1em}

\begin{itemize}
\item In \texttt{eq?} the address of the Lisp object is compared. For instance if we create two cons cells with same elements
\texttt{eq?} will give \texttt{\#f}
\begin{verbatim}
> (eq? (cons 'a 'b) (cons 'a 'b))
#f

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{car}, \texttt{cdr}, \texttt{cons}, \texttt{eq?}, \texttt{null?}, \texttt{quote} / \texttt{'}, \texttt{\#t}, \texttt{\#f},
\item Atoms, S-Expressions, Lists, Dotted Lists
\end{itemize}


\newpage
\section{Do It, Do It Again, and Again, and Again \ldots{}}
\label{sec:org933a314}

This chapter explains recursion. The best material for recursion in my opinion is Chapter 8 in Touretzky's book.

\vspace{1em}

Key Takeaway:
\emph{The First Commandment (preliminary): Always ask \texttt{NULL} as the first question in expressing a function}

\vspace{1em}
\begin{itemize}
\item After reading Touretzky's chapter on recursion this chapter will feel very easy. Also the first commandment is not
really true always. Sometimes in recursion the first question is not necessarily \texttt{NULL}. Let's use an example. Make
a recursive  function to compute a factorial of a number.
\begin{verbatim}
(defun fact (n)
  (cond ((zerop n) 1)
        (t (* n (fact (- n 1))))))

\end{verbatim}
Here the first question actually asks whether the argument \texttt{n} is a zero or not. Later in the book the authors do
add in this nuance.
\item The chapter introduces a function named \texttt{LAT?}. It stands for a \texttt{list of atoms}. This means every element of the
list is an \texttt{ATOM?}. We will use our own defined \texttt{ATOMP} predicate so that we do not return \texttt{T} for a \texttt{()}.
\item Recursive function definition of \texttt{LAT?} in Common Lisp.
\begin{verbatim}
(defun lat? (l)
  (cond ((null l) t)
        ((atom? (car l)) (lat? (cdr l)))
        (t nil)))

\end{verbatim}
\item It is important to understand how \texttt{COND} functions. Well \texttt{COND} is actually a macro. This macro has a series of
tests and results. The macro goes from top to bottom. The cases are processed from left to right under each test.
Technically we can have more than one result per test for evaluation. As a Common Lisp `trick' the last test is
usually a \texttt{T} which evaluates to \texttt{TRUE} always and hence the last result is returned. \texttt{COND} is a very nice way to
implement \texttt{If..then..Else}. I have never seen such seamless conditional in any language yet.
\item \texttt{LAT} basically is a \texttt{COND} which keeps checking through all the elements of a list to test for \texttt{ATOM?} till the
list ends. It checks \texttt{CAR} one by one for each subsequent \texttt{CDR} for \texttt{ATOMP}.
\item I would study Chapter 8 of Touretzky for getting the intuition on recursion right. The author has done a great job.
\item SBCL comes with an inbuilt tool called \texttt{TRACE} which lets us see the actual function calls. So lets trace all the
recursive examples in this chapter.
\begin{verbatim}
CL-USER> (lat? '(Jack Sprat could eat no chicken fat))
  0: (LAT? (JACK SPRAT COULD EAT NO CHICKEN FAT))
    1: (LAT? (SPRAT COULD EAT NO CHICKEN FAT))
      2: (LAT? (COULD EAT NO CHICKEN FAT))
        3: (LAT? (EAT NO CHICKEN FAT))
          4: (LAT? (NO CHICKEN FAT))
            5: (LAT? (CHICKEN FAT))
              6: (LAT? (FAT))
                7: (LAT? NIL)
                7: LAT? returned T
              6: LAT? returned T
            5: LAT? returned T
          4: LAT? returned T
        3: LAT? returned T
      2: LAT? returned T
    1: LAT? returned T
  0: LAT? returned T
T

\end{verbatim}
\item Another example which has a nested list
\begin{verbatim}
  CL-USER> (lat? '(Jack (Sprat could) eat no chickn fat))
  0: (LAT? (JACK (SPRAT COULD) EAT NO CHICKN FAT))
    1: (LAT? ((SPRAT COULD) EAT NO CHICKN FAT))
    1: LAT? returned NIL
  0: LAT? returned NIL
NIL

\end{verbatim}
\item Few more examples from the chapter using \texttt{TRACE}
\begin{verbatim}
CL-USER> (lat? '(bacon and eggs))
  0: (LAT? (BACON AND EGGS))
    1: (LAT? (AND EGGS))
      2: (LAT? (EGGS))
        3: (LAT? NIL)
        3: LAT? returned T
      2: LAT? returned T
    1: LAT? returned T
  0: LAT? returned T
T

\end{verbatim}

\begin{verbatim}
CL-USER> (lat? '(bacon (and eggs)))
  0: (LAT? (BACON (AND EGGS)))
    1: (LAT? ((AND EGGS)))
    1: LAT? returned NIL
  0: LAT? returned NIL
NIL

\end{verbatim}
\item \texttt{OR} is introduced as a logical operator. There is a very important point to note in the use of \texttt{OR} macro. Quoting
from Chapter 4 in Touretzky - The rule for evaluating \texttt{OR}: Evaluate the clauses one at a time. If a clause
returns something other than \texttt{NIL}, stop and return that value; otherwise go on to the next clause, or return
\texttt{NIL} if none are left. \texttt{AND} is not introduced in this chapter. Quoting the evaluation rule for \texttt{AND} - Evaluate
the clauses one at a time. If a clause returns \texttt{NIL}, stop and return \texttt{NIL}; otherwise go on to the next one. If all
clauses yield non-NIL results, return the value of the last clause.
\item \texttt{MEMBER} is a function which returns a \texttt{T} if the input is one of the elements in a list else \texttt{NIL\textasciitilde{}/\#f}. The book
defines this function using \texttt{OR} whereas it is actually not necessary.
\begin{verbatim}
(defun my-member (a lat)
  (cond ((null lat) nil)
        ((equal a (car lat)) t)
        (t (my-member a (cdr lat)))))

(defun member? (a lat)
  (cond ((null lat) nil)
        (t (or (equal (car lat) a) (member? a (cdr lat))))))

\end{verbatim}
\item The application of \texttt{member?} to find out whether \emph{meat} is in the list \emph{(mashed potatoes and meat gravy)} would
generate this recursive call
\begin{verbatim}
CL-USER> (member? 'meat '(mashed potatoes and meat gravy))
  0: (MEMBER? MEAT (MASHED POTATOES AND MEAT GRAVY))
    1: (MEMBER? MEAT (POTATOES AND MEAT GRAVY))
      2: (MEMBER? MEAT (AND MEAT GRAVY))
        3: (MEMBER? MEAT (MEAT GRAVY))
        3: MEMBER? returned T
      2: MEMBER? returned T
    1: MEMBER? returned T
  0: MEMBER? returned T
T

\end{verbatim}
\item Another example
\begin{verbatim}
CL-USER> (member? 'liver '(bagels and lox))
  0: (MEMBER? LIVER (BAGELS AND LOX))
    1: (MEMBER? LIVER (AND LOX))
      2: (MEMBER? LIVER (LOX))
        3: (MEMBER? LIVER NIL)
        3: MEMBER? returned NIL
      2: MEMBER? returned NIL
    1: MEMBER? returned NIL
  0: MEMBER? returned NIL
NIL

\end{verbatim}
\end{itemize}

\textbf{Core Terms/Concepts Learnt}
\begin{itemize}
\item \texttt{OR}
\item Basic template of recursion. Chapter 8 of Touretzky is great for a deeper dive into ways to constuct recursion. Also
tail optimized recursion is to be studied from the book `Sketchy Scheme' by Nils M Holm
\end{itemize}

\newpage

\section{Cons the Magnificent}
\label{sec:orgeb82e47}

This chapter explains the methods to build lists using \texttt{CONS} recursively.

\vspace{1em}

Key Takeaway:
\emph{Use \texttt{CONS} to build lists}

\vspace{1em}

\begin{itemize}
\item In last chapter we made a \texttt{MEMBER?} function and in this chapter we will be making a function which will \emph{remove}
a member
\item The first attempt to build the \texttt{REMBER} function fails since it removes all the initial elements before finding the
one it wants to remove. The authors have nicely demonstrated why \texttt{CONS} is required to define this function.
\item The way to write \texttt{REMBER} in Common Lisp is as below. Also note as per Scheme semantics there is no \texttt{?} at the end
of \texttt{REMBER} because it is actually not a predicate.
\begin{verbatim}
(defun rember (a lat)
  (cond ((null lat) nil)
        ((equal a (car lat)) (cdr lat))
        (t (cons (car lat)
                 (rember a (cdr lat))))))

\end{verbatim}
\item There is a way to contrast the incorrect \texttt{REMBER} with the correct \texttt{CONS} \texttt{REMBER} by looking at the recursive
trace calls. The incorrect \texttt{REMBER-WRONG} is below with its trace and return.
\begin{verbatim}
    (defun rember-wrong (a lat)
      (cond ((null lat) nil)
            ((equal a (car lat)) (cdr lat))
            (t (rember-wrong a (cdr lat)))))
CL-USER> (rember-wrong 'and '(bacon lettuce and tomato))
(TOMATO)

CL-USER> (rember-wrong 'and '(bacon lettuce and tomato))
  0: (REMBER-WRONG AND (BACON LETTUCE AND TOMATO))
    1: (REMBER-WRONG AND (LETTUCE AND TOMATO))
      2: (REMBER-WRONG AND (AND TOMATO))
      2: REMBER-WRONG returned (TOMATO)
    1: REMBER-WRONG returned (TOMATO)
  0: REMBER-WRONG returned (TOMATO)
(TOMATO)

\end{verbatim}
Whereas the correct trace and output is as below
\begin{verbatim}
CL-USER> (rember 'and '(bacon lettuce and tomato))
(BACON LETTUCE TOMATO)

CL-USER> (rember 'and '(bacon lettuce and tomato))
  0: (REMBER AND (BACON LETTUCE AND TOMATO))
    1: (REMBER AND (LETTUCE AND TOMATO))
      2: (REMBER AND (AND TOMATO))
      2: REMBER returned (TOMATO)
    1: REMBER returned (LETTUCE TOMATO)
  0: REMBER returned (BACON LETTUCE TOMATO)
(BACON LETTUCE TOMATO)

\end{verbatim}
Another example
\begin{verbatim}
CL-USER> (rember 'sauce '(soy sauce and tomato sauce))
  0: (REMBER SAUCE (SOY SAUCE AND TOMATO SAUCE))
    1: (REMBER SAUCE (SAUCE AND TOMATO SAUCE))
    1: REMBER returned (AND TOMATO SAUCE)
  0: REMBER returned (SOY AND TOMATO SAUCE)
(SOY AND TOMATO SAUCE)

\end{verbatim}
\end{itemize}











































\newpage

\section{Numbers Games}
\label{sec:org630f4a8}

\newpage

\section{* Oh My Gawd *: It's Full of Stars}
\label{sec:orgbaaf303}

\newpage

\section{Shadows}
\label{sec:org9c1bd59}

\newpage

\section{Friends and Relations}
\label{sec:org0f4838c}

\newpage

\section{Lambda the Ultimate}
\label{sec:org8684633}

\newpage

\section{\ldots{} and Again, and Again, and Again, \ldots{}}
\label{sec:org14d354c}

\newpage

\section{What Is the Value of All of This?}
\label{sec:org5f31f86}

\newpage

\section{Intermission}
\label{sec:org88724fe}

\newpage

\section{The Ten Commandments}
\label{sec:org38d3139}

\newpage

\section{The Five Rules}
\label{sec:orgd771fe0}

\newpage
\end{document}
